<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="前言 本人小白一枚，从18年入职工作到现在，工资不高，所在业务受重视程度更低。所以想趁着在家办公的时间，看看外面的世界。下面对面试过程中的问题进行分类汇总，这些问题的答案有个人认知、有参考他人的观点，" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>各大公司面试题分类整理 - 橘子果汁 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=Z9Vw4btcgJmrpUEjY_SgebmTmDXJ_hPFoST7ad2aJp4" />
    <link id="MainCss" rel="stylesheet" href="/skins/simplememory/bundle-simplememory.min.css?v=OL4qeo1LNGlN1rKIhv5UctANvt0M6Nx6kLzr_ffx3Xk" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/SimpleMemory/bundle-SimpleMemory-mobile.min.css" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/lvmengtian/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/lvmengtian/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/lvmengtian/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=98Fvfd6UZH20B_MF08daNaODjSu879MVR9RHmyvWAlg"></script>
    <script>
        var currentBlogId = 429825;
        var currentBlogApp = 'lvmengtian';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'SimpleMemory';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/lvmengtian/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/lvmengtian/">橘子果汁</a>
</h1>
<h2>
专注、坚持、自律
</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/lvmengtian/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E6%A9%98%E5%AD%90%E6%9E%9C%E6%B1%81">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/lvmengtian/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
10&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
2</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/lvmengtian/p/12796820.html">各大公司面试题分类整理</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <h1 id="前言">前言</h1>
<blockquote>
<p>本人小白一枚，从18年入职工作到现在，工资不高，所在业务受重视程度更低。所以想趁着在家办公的时间，看看外面的世界。下面对面试过程中的问题进行分类汇总，这些问题的答案有个人认知、有参考他人的观点，也有一些直接引用别人的文章。本文给出的答案只是一个引子，如果想要深入探究还需要各位通过其他渠道进行详细了解。<br><br>由于本人知识有限，答案不免有不足或者错误。还望各位犀利指出，小白一定积极改正，进行勘误。</p>
</blockquote>
<h1 id="面试题汇总">面试题汇总</h1>
<h2 id="工作相关篇">工作相关篇</h2>
<p><strong>Q1: 自己所做过的项目中难点以及如何解决的，介绍系统的业务架构和技术架构</strong><br>
这是一个必问题，所以需要提前准备好项目中的难点以及自己的解决方案。如果是自己遇到并解决的最好，如果自己没有遇到过，那么把项目中其他人解决的难点融会贯通也可。总之：要有亮点，而且自己是深入思考和深入理解的。</p>
<p><strong>Q2: 服务突然RT增大，后续又恢复了，如何定位</strong></p>
<ol>
<li>可能是网络抖动，导致接口短暂超时</li>
<li>gc影响</li>
</ol>
<h2 id="java篇">Java篇</h2>
<h3 id="java基础">Java基础</h3>
<p><strong>Q1: Java环境变量classpath和path的区别</strong></p>
<ol>
<li>path环境变量：系统用来指定可执行文件的完整路径，即使不在path中设置JDK的路径也可执行JAVA文件，但必须把完整的路径写出来</li>
<li>classpath环境变量：java查找类的路径</li>
</ol>
<p><strong>Q2: 重写和重载的区别，构造函数可以重写吗</strong></p>
<pre><code class="language-java">class Person {
    String name;
    public Person() {}
    public Person(String name) {this.name = name;}
    public void talk() {System.out.println(&quot;person talk&quot;);}
}
class Student extends Person {
    String stuNumber;
    public Student() {}
    public Student(String name, String stuNumber) {
        super(name);
        this.stuNumber = stuNumber;
    }
    @Override
    public void talk() {System.out.println(&quot;student talk&quot;);}
}
</code></pre>
<p>重写：需要有继承关系，子类重写父类的方法。一般使用<code>@Override</code>注解标识，不标识也无所谓。上面代码中<code>Student</code>类就重写了<code>Person</code>类的<code>talk</code>方法。</p>
<p>重载：函数名相同，参数个数不同或者参数类型不同。注意方法返回值不同是不算重载的。上面代码中对构造函数就是通过参数个数不同进行重载。</p>
<p>构造函数不能被重写，因为重写要求方法名一致。而构造函数的方法名就是类名。子类不可能和父类同名，所以也不可能有相同的构造函数。所以构造函数不能重写，但是可以重载。</p>
<p><strong>Q3: 介绍一些常用的Java工具命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>jps</td>
<td>虚拟机进程状态工具，可以列出虚拟机进程</td>
</tr>
<tr>
<td>jstat</td>
<td>虚拟机统计信息监视工具，监视虚拟机各种运行状态信息</td>
</tr>
<tr>
<td>jinfo</td>
<td>Java配置信息工具</td>
</tr>
<tr>
<td>jmap</td>
<td>生成堆转储快照</td>
</tr>
</tbody>
</table>
<h3 id="集合">集合</h3>
<p><strong>Q1: HashMap实现原理</strong></p>
<p>请参考：<a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java HashMap工作原理及实现</a></p>
<p><strong>Q2: HashMap为什么线程不安全</strong></p>
<p>请参考：<a href="https://blog.csdn.net/weixin_43092168/article/details/89791106">HashMap为什么不是线程安全？</a></p>
<p><strong>Q3: currentHashMap如何保证线程安全</strong></p>
<p>请参考：<a href="https://baijiahao.baidu.com/s?id=1617089947709260129&amp;wfr=spider&amp;for=pc">高并发编程系列：ConcurrentHashMap的实现原理(JDK1.7和JDK1.8)</a></p>
<p><strong>Q4: Java容器有哪些？哪些是同步容器，哪些是并发容器？</strong></p>
<p>详细可参考：<a href="https://blog.csdn.net/qq_20499001/article/details/89031480?fps=1&amp;locationNum=2">Java同步容器和并发容器</a></p>
<p>Java容器有Map、List、Set<br>
<img src="https://user-gold-cdn.xitu.io/2020/3/28/171216696aab5531?w=1506&amp;h=604&amp;f=png&amp;s=84230" alt=""></p>
<p>Java中同步容器分为2类:</p>
<ol>
<li>Vector/Stack/HashTable，其方法都是同步方法，使用<code>synchronized</code>修饰</li>
<li>Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXxxx 等方法）</li>
</ol>
<p>Java中的并发容器:<br>
JDK 的 java.util.concurrent 包（即 juc）中提供了几个非常有用的并发容器。</p>
<ol>
<li>CopyOnWriteArrayList - 线程安全的 ArrayList</li>
<li>CopyOnWriteArraySet - 线程安全的 Set，它内部包含了一个 CopyOnWriteArrayList，因此本质上是由 CopyOnWriteArrayList 实现的。</li>
<li>ConcurrentSkipListSet - 相当于线程安全的 TreeSet。它是有序的 Set。它由 ConcurrentSkipListMap 实现。</li>
<li>ConcurrentHashMap - 线程安全的 HashMap。采用分段锁实现高效并发。</li>
<li>ConcurrentSkipListMap - 线程安全的有序 Map。使用跳表实现高效并发。</li>
<li>ConcurrentLinkedQueue - 线程安全的无界队列。底层采用单链表。支持 FIFO。</li>
<li>ConcurrentLinkedDeque - 线程安全的无界双端队列。底层采用双向链表。支持 FIFO 和 FILO。</li>
<li>ArrayBlockingQueue - 数组实现的阻塞队列。</li>
<li>LinkedBlockingQueue - 链表实现的阻塞队列。</li>
<li>LinkedBlockingDeque - 双向链表实现的双端阻塞队列。</li>
</ol>
<h3 id="线程">线程</h3>
<p><strong>Q1: 如何让线程A在线程B执行之后再执行</strong></p>
<ol>
<li>CountDownLatch。线程A中 <code>latch.await()</code>，线程B中<code>latch.countDown()</code></li>
<li>wait()、notify()。可能存在线程B的<code>notify()</code>先执行，导致线程A一直处于阻塞状态</li>
</ol>
<p><strong>Q2: ThreadLocal的理解和适用场景</strong></p>
<p>请参考：<a href="https://www.cnblogs.com/fsmly/p/11020641.html">Java中的ThreadLocal详解</a></p>
<p>Thread类里面有2个变量，threadLocals和inheritableThreadLocals，类型均为ThreadLocalMap。</p>
<blockquote>
<p>为什么Thread类使用map，而不是直接一个value的存储( T value)，如果是一个T value的话，这个值就是多个线程共享的，会出现问题。ThreadLocal就是为了解决该问题而来的</p>
</blockquote>
<p>使用ThreadLocal注意事项：<br>
ThreadLocalMap中的Entry的key使用的是ThreadLocal对象的弱引用，在没有其他地方对ThreadLoca依赖，ThreadLocalMap中的ThreadLocal对象就会被回收掉，但是对应的value不会被回收，这个时候Map中就可能存在key为null但是value不为null的项，这需要实际的时候使用完毕及时调用remove方法避免内存泄漏。</p>
<p><strong>Q3: 一个线程的生命周期有哪几种状态？它们之间如何流转的</strong></p>
<p>请参考：<a href="https://www.cnblogs.com/sunddenly/p/4106562.html">Java多线程学习(三)---线程的生命周期</a></p>
<p><strong>Q4: 线程池提交流程</strong><br>
<img src="https://user-gold-cdn.xitu.io/2020/3/28/1712195d558c50a6?w=1802&amp;h=580&amp;f=png&amp;s=98234" alt=""></p>
<p><strong>Q5: 线程池中任务队列已满，如何处理</strong></p>
<ul>
<li>AbortPolicy：直接抛出RejectedExecutionException异常。<strong>是Executors里面默认线程池的默认处理策略</strong></li>
<li>DiscardPolicy：do nothing</li>
<li>DiscardOldestPolicy：抛弃最老的任务，执行新的</li>
<li>CallerRunsPolicy：调用线程执行</li>
</ul>
<p><strong>Q6: 保证线程安全的方式</strong></p>
<ul>
<li>automic：使用提供的原子类</li>
<li>syntronized：同步代码块</li>
<li>lock：锁</li>
<li>volatile：保证可见性</li>
</ul>
<h3 id="锁">锁</h3>
<p><strong>Q1: 同步方法的锁是类还是对象</strong><br>
同步方法默认用this或者当前类class对象作为锁；<br>
同步代码块是通过传入的对象作为锁。</p>
<p><strong>Q2: 同步方法A调用同步方法B，能进入嘛</strong><br>
可以，因为<code>synchronized</code>是可重入锁</p>
<p><strong>Q3: synchonized和ReentrantLock的区别</strong><br>
<strong>不同点</strong></p>
<ol>
<li><code>synchonized</code>是java的关键字；<code>ReentrantLock</code>是类</li>
<li><code>synchonized</code>是非公平锁；<code>ReentrantLock</code>默认是非公平锁，但是有公平锁和非公平锁两种实现方式。</li>
<li><code>synchonized</code>可用在同步代码块、同步方法上；<code>ReentrantLock</code>的使用方式需要<code>lock()</code>和<code>unlock()</code></li>
</ol>
<p><strong>相同点</strong></p>
<ol>
<li>两者都是可重入锁</li>
<li>都是同步阻塞方式</li>
</ol>
<p><strong>Q4: 什么是活锁、饥饿、无锁、死锁？怎么检测一个线程是否拥有锁</strong></p>
<p><strong>死锁:</strong><br>
是指<strong>两个或两个以上的进程（或线程）</strong> 在执行过程中，因 <strong>争夺资源而造成的一种互相等待</strong> 的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><strong>死锁的条件:</strong></p>
<ol>
<li>
<p><strong>互斥：</strong> 线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么<strong>其他线程必须处于等待状态</strong>，直到资源被释放。</p>
</li>
<li>
<p><strong>请求和保持：</strong> 线程T1至少已经保持了一个资源R1占用,但又提出对另一个资源R2请求，而此时，资源R2被其他线程T2占用，于是该线程T1也必须等待，但又对自己保持的资源R1不释放。</p>
</li>
<li>
<p><strong>不可剥夺：</strong> 线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。</p>
</li>
<li>
<p>循环等待</p>
</li>
</ol>
<p><strong>活锁</strong><br>
是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<p>举个例子:马路中间有条小桥，只能容纳一辆车经过，桥两头开来两辆车A和B，A比较礼貌，示意B先过，B也比较礼貌，示意A先过，结果两人一直谦让谁也过不去。</p>
<p><strong>饥饿</strong><br>
是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。</p>
<p>不公平锁能够提高吞吐量但不可避免的会造成某些线程的饥饿，或者优先级低的线程容易产生饥饿</p>
<p><strong>无锁:</strong><br>
无锁，即没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁典型的特点就是一个修改操作在一个循环内进行，线程会不断的尝试修改共享资源，如果没有冲突就修改成功并退出否则就会继续下一次循环尝试。所以，如果有多个线程修改同一个值必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。<strong>CAS</strong> 原理及应用即是无锁的实现。</p>
<p><strong>检测线程是否有锁</strong><br>
<code>Thread.holdsLock(Object obj)</code>：当且仅当 当前线程拥有<code>obj</code>对象锁的时候，返回<code>true</code>。<br>
该方法用例断言打当前线程是否持有锁。<code>assert Thread.holdsLock(obj);</code></p>
<p><strong>Q5: synchronized实现原理</strong></p>
<p><strong>Q6: java中悲观锁、乐观锁的例子</strong></p>
<ul>
<li>Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</li>
<li>java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的</li>
</ul>
<h3 id="jvm">jvm</h3>
<p><strong>Q1: 介绍一些了解的JVM参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>最小堆大小</td>
<td>一般-Xms和-Xmx大小相等，避免内存的扩展</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆大小</td>
<td>一般-Xms和-Xmx大小相等，避免内存的扩展</td>
</tr>
<tr>
<td>-Xmn</td>
<td>年轻代大小</td>
<td>其中分了1个Eden和2个Survivor；默认比例 8：1</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>eden和survivor的比例</td>
<td>默认8:1</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>永久代大小</td>
<td>-XX:PermSize与-XX:MaxPermSize大小最好一致，避免运行时自动扩展</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>永久带最大值</td>
<td>-XX:PermSize与-XX:MaxPermSize大小最好一致</td>
</tr>
<tr>
<td>-XX:+UserConcMarkSweepGC</td>
<td>使用CMS收集器</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Q2: 为什么 Java 要采用垃圾回收机制，而不采用 C/C++的显式内存管理</strong></p>
<p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象 的内存时，该内存便成为垃圾。 垃圾回收能自动释放内存空间，减轻编程的负担，JVM的一个系统级线程会自动释放该内存块。<strong>释放无用内存，避免内存泄漏</strong></p>
<p>Java禁止显示内存回收，jvm决定回收时机，而且避免开发人员忘记释放内存的问题</p>
<p><strong>Q3: JVM内存模型</strong><br>
<img src="https://user-gold-cdn.xitu.io/2020/3/29/171240a63da902f4?w=1090&amp;h=982&amp;f=png&amp;s=535422" alt=""></p>
<p><strong>Q4: JVM内存分配策略</strong></p>
<ol>
<li>对象优先分配在Eden区，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。垃圾收集期间虚拟机对象全部无法放入Survivor空间，通过分配担保机制提前转移到老年代去。</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象进入老年代，可以通过-XX：MaxTenuringThreshold设置年龄</li>
<li>动态对象年龄判定。为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄</li>
</ol>
<p><strong>Q5: 有哪些垃圾回收算法</strong></p>
<ul>
<li>标记-清除：会产生内存碎片</li>
<li>标记-复制：年轻代采用该算法进行垃圾收集</li>
<li>标记-整理：让所有存活的对象都向内存空间一端移动，延迟增大</li>
</ul>
<h3 id="类加载">类加载</h3>
<p>关于类加载器看这一篇文章就够了。<a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247483903&amp;idx=1&amp;sn=c20d3172052bd7db9a1ad6a95f112bc9&amp;chksm=96cda0b2a1ba29a4cc9912cb1bf8a955f97ee45a7b8db48e384f1694ddbabbd4d5e7fa90f880&amp;mpshare=1&amp;scene=23&amp;srcid=0327b2qp5X0Mmlhqfwu6TNug#rd">深入理解Java类加载机制</a>。但是这篇文章最后有一个错误：下面图片中<code>此时的counter2=1</code>应该是<code>counter2=0</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/29/1712407f156b936e?w=1430&amp;h=332&amp;f=png&amp;s=101771" alt=""></p>
<p><strong>Q1: classLoader和Class.forName()的区别</strong></p>
<p>java中class.forName()和classLoader都可用来对类进行加载。<br>
class.forName()前者除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。<br>
而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。<br>
Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</p>
<h2 id="mysql篇">MySQL篇</h2>
<p><strong>Q1: MySQL存在哪些索引类型</strong></p>
<ol>
<li>唯一索引</li>
<li>全文索引</li>
<li>联合索引</li>
<li>普通索引</li>
</ol>
<p><strong>Q2: InnoDB为什么采用B+树的索引结构</strong></p>
<p>请参考腾讯技术工程的文章：<a href="https://zhuanlan.zhihu.com/p/113917726?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=758594092891385856">深入理解 Mysql 索引底层原理</a>。</p>
<p><strong>Q3: 介绍聚簇索引、非聚簇索引、索引覆盖</strong></p>
<p>请参考文章：<a href="https://www.csdn.net/gather_26/MtTaIgysMTUxNS1ibG9n.html">mysql聚簇索引和非聚簇索引</a></p>
<p><strong>Q4: 如何提高SQL性能，工作中SQL优化经验</strong></p>
<p>提高SQL的性能我认为一定要让MySQL选择正确的索引。</p>
<p>在工作中，小白曾优化过系统中的SQL。其体现主要表现在以下几个方面（这只是小白在工作中遇到的，跟各位遇到的应该会有不同哦）：</p>
<ol>
<li>MySQL错误选择索引</li>
<li>字段类型错误导致没走索引</li>
<li>本可使用索引覆盖的SQL语句，却回表查了多余数据</li>
</ol>
<p><strong>Q5: MySQL数据库隔离级别</strong></p>
<p>请参考：<a href="https://lvmengtian.github.io/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html">Mysql数据库隔离级别</a></p>
<h2 id="spring篇">Spring篇</h2>
<p><strong>Q1: 介绍Spring IOC和AOP</strong></p>
<p>请参考：<a href="https://blog.csdn.net/dkbnull/article/details/87219562">深入理解Spring两大特性：IoC和AOP</a></p>
<p>IOC：控制反转。IOC之前对象A依赖对象B时，需要A主动去通过new创建B的实例，控制权是在对象A上。IOC就是将对象的控制权交给IOC容器处理。</p>
<p>AOP：面向切面编程（AOP）就是纵向的编程。比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。<strong>AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等</strong></p>
<p><strong>Q2: AOP如何实现</strong></p>
<p>Spring通过动态代理实现AOP。</p>
<p>请参考：<a href="https://juejin.im/post/5b90e648f265da0aea695672">从代理机制到Spring AOP</a></p>
<p><strong>Q3: Spring如何实现事务管理</strong></p>
<p>请参考：<a href="https://juejin.im/post/5b00c52ef265da0b95276091">可能是最漂亮的Spring事务管理详解</a></p>
<p><strong>Q4: Spring事务传播机制</strong></p>
<p>请参考：<a href="https://juejin.im/entry/5a8fe57e5188255de201062b">Spring事务传播行为详解</a></p>
<h2 id="redis篇">Redis篇</h2>
<p><strong>Q1: redis如何实现分布式锁</strong></p>
<p>使用<code>setnx key value</code>实现，并使用<code>expire key</code> 设置超时时间。</p>
<p>这种方式存在的问题：这2步操作由于不是一个事务，所以可能出现设置超时时间失败的问题。如果超时时间设置失败则会导致该<code>key</code>永不过期，占用内存。</p>
<p>解决方式：</p>
<ol>
<li>可使用lua脚本自己编写，使之变成一个原子性操作</li>
<li>redis提供了<code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code></li>
</ol>
<p><strong>Q2: redis有支持几种数据结构</strong></p>
<p>String、List、Set、Zset、Map、GEO、Bitmap</p>
<p><strong>Q3: 字符串数据结构底层实现</strong></p>
<p>Redis的字符串底层由SDS简单动态字符串实现。</p>
<p><strong>特性</strong></p>
<ol>
<li>空间预分配：当修改字符串并需要空间扩展时，分为以下2种情况：
<ol>
<li>扩展之后空间小于1M，则预分配与已使用空间一样大小的空间(已使用空间包含扩展之后的字符串)</li>
<li>扩展之后空间大于1M，则直接分配1M</li>
</ol>
</li>
<li>惰性释放：为了避免释放之后再扩展的问题，redis采用了惰性释放策略，使用<code>free</code>字段来记录未使用的长度，等待使用。同时也提供了相关的API再有需要时释放空间。</li>
</ol>
<p><strong>Q4: Map数据结构底层实现</strong></p>
<p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<p>字典数据结构中是一个哈希表数组，共有2个哈希表。在扩容时使用。</p>
<p>Redis的hash算法使用MurmurHash2算法。</p>
<p><strong>Q5: Redis过期键删除策略</strong></p>
<p><strong>定时删除：</strong> 在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。<br>
<strong>优点：</strong> 内存友好，可以实时释放内存<br>
<strong>缺点：</strong> 对CPU不友好，为了删除过期键，大量占用CPU</p>
<p><strong>惰性删除：</strong> 放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键<br>
<strong>优点：</strong> 对CPU友好，只有使用到的时候才判断<br>
<strong>缺点：</strong> 对内存不友好<br>
<strong>实现：</strong> 通过expireIfNeeded函数，读写redis命令之前都会调用该函数，判断是否需要过期该键</p>
<p><strong>定期删除：</strong> 每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定<br>
<strong>优点：</strong> 兼顾内存和CPU<br>
<strong>实现：</strong> Redis的服务器周期性操作redis.c/serverCron函数执行时，activeExpireCycle函数就会被调用。函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</p>
<p><strong>Q6: redis的淘汰策略</strong></p>
<ul>
<li>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</li>
<li>allkeys-lru：从所有key中使用LRU算法进行淘汰</li>
<li>volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</li>
<li>allkeys-random：从所有key中随机淘汰数据</li>
<li>volatile-random：从设置了过期时间的key中随机淘汰</li>
<li>volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</li>
</ul>
<p><strong>Q7: zset的底层实现</strong></p>
<p>跳跃表。可参考<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16#heading-4">通俗易懂的Redis数据结构基础教程</a></p>
<h2 id="kafka篇">Kafka篇</h2>
<p><strong>Q1: Kafka如何保证高性能和可靠性</strong></p>
<p>请参考：<a href="https://www.infoq.cn/article/depth-interpretation-of-kafka-data-reliability/">Kafka 数据可靠性深度解读</a>。</p>
<p><em>画外音：该文章需要细细阅读，理解每一块内容。只要明白了该文章里所说内容，应对面试中的Kafka面试题应该不成问题。</em></p>
<p><strong>Q2: Kafka支持事务嘛</strong></p>
<p>请参考：<a href="https://www.infoq.cn/article/kafka-analysis-part-8">Kafka 设计解析（八）：Kafka 事务机制与 Exactly Once 语义实现原理</a></p>
<p><strong>Q3: Kafka中zookeeper的作用</strong></p>
<ul>
<li>再平衡消费者</li>
<li>选主</li>
</ul>
<h2 id="编程题">编程题</h2>
<blockquote>
<p>基本都是Leetcode的中等难度的题目，各位小伙伴可以刷起来了</p>
</blockquote>
<p><strong>Q1: 求A/B，不能使用除法</strong></p>
<p>详细讲解请看：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MzUwNjcwMA==&amp;mid=100000247&amp;idx=1&amp;sn=cce83aa6f670dd2cba786f6a4776fef2&amp;scene=19#wechat_redirect">两数相除</a></p>
<pre><code class="language-java">public int divide(int dividend, int divisor) {
    if (dividend == 0) {
      return 0;
    }
    if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) {
      return Integer.MAX_VALUE;
    }
    int flag = -1;
    if ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) {
      flag = 1;
    }
    long a = Math.abs((long) dividend);
    long b = Math.abs((long) divisor);
    return flag * getRes(a, b);
  }

  private int getRes(long a, long b) {
    if (a &lt; b) {
      return 0;
    }
    int count = 1;
    long tmp = b;
    while (a &gt; b &lt;&lt; 1) {
      b = b &lt;&lt; 1;
      count = count &lt;&lt; 1;
    }
    return count + getRes(a - b, tmp);
  }
</code></pre>
<p><strong>Q2: 给定包含n个数字的数组，将这些数字进行拼接，求拼接成的最大数值</strong></p>
<p><strong>Q3: 链表中找到倒数第K个节点</strong></p>
<p><strong>Q4: 买卖股票的最佳时机</strong></p>
<p>为了找到最大利润，我们需要找到最小的买入价格。假设<code>nums[i]</code>是最低的买入价格，<code>nums[j]</code>是最高的买入价格。当满足<code>i &lt; j</code>时的最大利润即为<code>nums[j] - nums[i]</code>。</p>
<p>详细描述请参考：<a href="https://lvmengtian.github.io/algorithm/leetcode/121.html">121. 买卖股票的最佳时机</a></p>
<pre><code class="language-java">public int maxProfit(int[] prices) {
    int len = prices.length;
    if (len &lt;= 1) {
        return 0;
    }
    // 存储最小的买入价格
    int minBuyPrice = prices[0];
    
    // 存储最高的卖出价格
    int maxSellPrice = 0;
    
    for (int i = 1; i &lt; len; i++) {
        // 计算最高的卖出价格：当前最高卖出价格与当天的卖出价格对比。其中price[i]-minBuyPrice就是当天的卖出价格
        maxSellPrice = Math.max(maxSellPrice, prices[i] - minBuyPrice);
        
        // 更新最小的买入价格
        minBuyPrice = Math.min(minBuyPrice, prices[i]);
    }
    return maxSellPrice;
}
</code></pre>
<p><strong>Q5: 复制带随机指针的链表</strong></p>
<p><strong>Q6: 消除816。例如原字符串12881616，最终返回12。12881616 -&gt; 12816 -&gt; 12</strong></p>
<blockquote>
<p>提示：使用栈数据结构</p>
</blockquote>
<p><strong>Q7: 数组中奇数、偶数数量相同，交换内容最终使得奇数下标存储奇数，偶数下标存储偶数</strong></p>
<p><strong>Q8: leetcode 154题</strong></p>
<p>链接：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值II</a></p>
<p>解题思路，欢迎查阅小白的个人博客：<a href="https://lvmengtian.github.io/algorithm/leetcode/154.html">154. 寻找旋转排序数组中的最小值II</a></p>
<p><strong>Q9: 单链表结构，每个节点表示0-9的数字。给定2个链表，进行求和。例如 9-&gt;9和2-&gt;1。求和结果是1-&gt;2-&gt;2</strong></p>
<p>三种思路，请参考：<a href="https://lvmengtian.github.io/algorithm/leetcode/445.html">Leetcode 445. 两数相加 II</a></p>
<p><strong>Q10：实现一个LRU数据结构，插入和查询要求$O(1)$时间复杂度</strong></p>
<ol>
<li>可以使用LinkedHashMap直接实现。</li>
<li>使用一个<code>LinkedList</code>存储<code>key</code>的顺序吗，到达O(1)的插入，使用<code>map</code>存储k-v映射关系，达到O(1)的查询复杂度</li>
</ol>
<pre><code class="language-java">public class Main {
    // 使用map存储结构中已有的key，便于O(1)的查询复杂度
	HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
	// 存储key的顺序，对于最近访问的key，移动到队列的头部
	LinkedList&lt;String&gt; lruKeys = new LinkedList&lt;&gt;();
	// LRU结构的大小
	int size = 4;

	public static void main(String[] args) {
		Main main = new Main();
		main.set(&quot;math&quot;, 100);
		main.set(&quot;chiness&quot;, 200);
		main.set(&quot;english&quot;, 210);
		main.print();

		System.out.println(&quot;-------&quot;);

		main.set(&quot;music&quot;, 250);
		main.set(&quot;draw&quot;, 250);
		main.print();

		System.out.println(&quot;-------&quot;);
		main.get(&quot;english&quot;);
		main.print();
	}

	private void print() {
		for (String key : lruKeys) {
			System.out.println(key + &quot; = &quot; + map.get(key));
		}
	}

	private void set(String key, int val) {
		if (map.containsKey(key)) {
			map.put(key, val);
			moveToFirst(key);
		} else {
			if (lruKeys.size() == size) {
				String removeKey = lruKeys.removeLast();
				map.remove(removeKey);
			}
			map.put(key, val);
			lruKeys.addFirst(key);
		}
	}

	private int get(String key) {
		if (map.containsKey(key)) {
			moveToFirst(key);
			return map.get(key);
		}
		return 0;
	}

	private void moveToFirst(String key) {
		lruKeys.remove(key);
		lruKeys.addFirst(key);
	}
}
</code></pre>
<p><strong>Q11：最长回文子串</strong></p>
<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">Leetcode 5:最长回文子串</a></p>
<h2 id="思维题">思维题</h2>
<p><strong>Q1: 36辆车，6个跑道，最少多少次可以筛选出跑的最快的3辆车（不可用表计时）</strong></p>
<p>8次 = 6 + 1 + 1。</p>
<p>分析：</p>
<ol>
<li>首先将36辆车随机分成6组进行比赛，对每组进行排名并选择出每组的第一名（6次）</li>
<li>将步骤1结果的6辆车再进行一轮比赛，并选择出前三名，假设分别为A车、B车、C车（1次）</li>
<li>然后从A车所在的组（步骤1的分组）选出第2、3名，从B车所在的组（步骤1的分组）选出第2名。（因为A车第一，所以存在A车所在组的第2、3名比B、C车块的可能性；同理B车所在组的第2名存在比C车块的可能性；由于只选最快的3辆车，所以无需从C车所在组进行选车）</li>
<li>然后将步骤3选择出来的3辆车再加上A车、B车、C车进行一次比赛，选择出前三名（1次）</li>
<li>步骤4的结果就是最快的3辆车</li>
</ol>
<p><strong>Q2: 1000w个数据中找出重复的</strong></p>
<p>使用bitmap。不要使用布隆过滤器，因为布隆过滤器并非100%准确。</p>
<p><strong>Q3: 有2个玻璃球和一栋256层的高楼，如何快速定位到使得玻璃球摔碎的最低楼层</strong></p>
<p>方案一：拿玻璃球一层层由低到高测试。</p>
<p>方案二：二分法。但是如果在中间的时候玻璃球碎了，那就无法再二分了，只能一层层的实验。</p>
<p>方案三：拿玻璃球测试楼层为n，2n，3n....这种。如果玻璃球在2n层摔坏了，则那另一个玻璃球从n+1 到 2n-1的楼层逐层实验。</p>
<p>其实可以看出来方案三中n=1时，就是方案一逐层实验；当n=128时，就是方案二。那我们如何求出n来使得结果最优呢？</p>
<p>假设使得玻璃球碎的楼层是256，步长n。则此时的次数为:256/n+n。要想该数值最小，则需要256/n = n。所以n = 16。</p>
<h1 id="面试心得">面试心得</h1>
<h2 id="面试前">面试前</h2>
<ol>
<li>准备简历，并保证简历中没有错别字。</li>
<li>简历中技能栏和项目栏中的项目一定要熟练。对于某技术熟悉就是熟悉、了解就是了解，要实事求是。否则被面试官问住是一件很尴尬的事情</li>
<li>准备1~2分钟的自我介绍</li>
<li>先拿几家不想去公司试试手，因为一开始面试被pass的几率很大</li>
<li>临近面试时，提前准备几个给面试官的问题，面试之后进行沟通。</li>
</ol>
<h2 id="面试中">面试中</h2>
<ol>
<li>不要紧张，遇到问题会就是会，不会就是不会。即使不会也可以说一下自己的思考和理解。</li>
<li>针对编程题，需要充分考虑边界问题和异常情况</li>
</ol>
<h2 id="面试后">面试后</h2>
<ol>
<li>对刚才的面试进行复盘。针对不会的问题或者答得不好的问题，进行总结并收集相关知识点。</li>
</ol>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-04-28 19:54</span>&nbsp;
<a href="https://www.cnblogs.com/lvmengtian/">橘子果汁</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12796820" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12796820);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 429825, cb_blogApp = 'lvmengtian', cb_blogUserGuid = 'cf642f89-c0de-46f2-e0d1-08d5a91b4f51';
    var cb_entryId = 12796820, cb_entryCreatedDate = '2020-04-28 19:54', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 橘子果汁
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <div>
转载请注明出处
</div>
    </div>
</body>
</html>