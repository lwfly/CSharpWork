<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">博客园_冯辉</title>
  <subtitle type="text"></subtitle>
  <id>uuid:94848990-6bc9-4837-a55f-0033142bd3af;id=762</id>
  <updated>2020-04-28T14:01:53Z</updated>
  <author>
    <name>HueiFeng</name>
    <uri>http://www.cnblogs.com/yyfh/</uri>
  </author>
  <generator>feed.cnblogs.com</generator>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12797600.html</id>
    <title type="text">.NET Core 使用MediatR CQRS模式 - HueiFeng</title>
    <summary type="text">前言 CQRS ( Command Query Responsibility Segregation )命令查询职责分离模式，它主要从我们业务系统中进行分离出我们(Command 增、删、改)和（Query 查）, 同时他可以明确的区分我们每一个动作向我们的请求模型和响应模型.从而降低了我们系统的复</summary>
    <published>2020-04-28T14:02:00Z</published>
    <updated>2020-04-28T14:02:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12797600.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12797600.html" />
    <content type="html">【摘要】前言 CQRS ( Command Query Responsibility Segregation )命令查询职责分离模式，它主要从我们业务系统中进行分离出我们(Command 增、删、改)和（Query 查）, 同时他可以明确的区分我们每一个动作向我们的请求模型和响应模型.从而降低了我们系统的复 &lt;a href="http://www.cnblogs.com/yyfh/p/12797600.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12689422.html</id>
    <title type="text">HttpClient来自官方的JSON扩展方法 - HueiFeng</title>
    <summary type="text">System.Net.Http.Json Json的序列化和反序列化是我们日常常见的操作，通过 System.Net.Http.Json 我们可以用少量的代码实现上述操作.正如在github设计文档中所描述 Serializing and deserializing JSON payloads fr</summary>
    <published>2020-04-13T01:32:00Z</published>
    <updated>2020-04-13T01:32:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12689422.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12689422.html" />
    <content type="html">【摘要】System.Net.Http.Json Json的序列化和反序列化是我们日常常见的操作，通过 System.Net.Http.Json 我们可以用少量的代码实现上述操作.正如在github设计文档中所描述 Serializing and deserializing JSON payloads fr &lt;a href="http://www.cnblogs.com/yyfh/p/12689422.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12684209.html</id>
    <title type="text">TypeScript联合类型 接口 - HueiFeng</title>
    <summary type="text">TypeScript联合类型 联合类型表示取值可以为多种类型中的一种 如下所示 这一块我们必须使用string或者number都支持的类型，那么下面我们可以进行调用扩展方法toString() TypeScript中对象类型 接口 接口可以描述一种抽象的行为，也可以描述对象的结构形状,当然我们也需要</summary>
    <published>2020-04-12T03:09:00Z</published>
    <updated>2020-04-12T03:09:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12684209.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12684209.html" />
    <content type="html">【摘要】TypeScript联合类型 联合类型表示取值可以为多种类型中的一种 如下所示 这一块我们必须使用string或者number都支持的类型，那么下面我们可以进行调用扩展方法toString() TypeScript中对象类型 接口 接口可以描述一种抽象的行为，也可以描述对象的结构形状,当然我们也需要 &lt;a href="http://www.cnblogs.com/yyfh/p/12684209.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12636976.html</id>
    <title type="text">ASP.NET Core MVC通过IViewLocationExpander扩展视图搜索路径 - HueiFeng</title>
    <summary type="text">IViewLocationExpander API ExpandViewLocations Razor视图路径，视图引擎会搜索该路径. PopulateValues 每次调用都会填充路由 项目目录如下所示 创建区域扩展器，其实我并不需要多区域，我目前只需要达到一个区域中有多个文件夹进行存放我的视图.</summary>
    <published>2020-04-05T05:47:00Z</published>
    <updated>2020-04-05T05:47:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12636976.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12636976.html" />
    <content type="html">【摘要】IViewLocationExpander API ExpandViewLocations Razor视图路径，视图引擎会搜索该路径. PopulateValues 每次调用都会填充路由 项目目录如下所示 创建区域扩展器，其实我并不需要多区域，我目前只需要达到一个区域中有多个文件夹进行存放我的视图. &lt;a href="http://www.cnblogs.com/yyfh/p/12636976.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12631578.html</id>
    <title type="text">【翻译】.NET 5 Preview2发布 - HueiFeng</title>
    <summary type="text">在4月2日，发布了.NET 5.0 Preview2，这次发布对一些功能和性能做了相关的改进，同时后面也会实施5.0版本更多的功能，其中一些功能设计目前也在 "dotnet/designs" 中显示，在 ".NET 5 Preview1" 中可以看到.NET 5里程碑中已经完成的建设任务，当然可以查</summary>
    <published>2020-04-04T05:58:00Z</published>
    <updated>2020-04-04T05:58:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12631578.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12631578.html" />
    <content type="html">【摘要】在4月2日，发布了.NET 5.0 Preview2，这次发布对一些功能和性能做了相关的改进，同时后面也会实施5.0版本更多的功能，其中一些功能设计目前也在 "dotnet/designs" 中显示，在 ".NET 5 Preview1" 中可以看到.NET 5里程碑中已经完成的建设任务，当然可以查 &lt;a href="http://www.cnblogs.com/yyfh/p/12631578.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12602087.html</id>
    <title type="text">ASP.NET Core AutoWrapper 自定义响应输出 - HueiFeng</title>
    <summary type="text">前言 AutoWrapper是一个简单可自定义全局异常处理程序和ASP.NET Core API响应的包装。他使用ASP.NET Core middleware拦截传入的HTTP请求，并将最后的结果使用统一的格式来自动包装起来.目的主要是让我们更多的关注业务特定的代码要求，并让包装器自动处理HTTP</summary>
    <published>2020-03-30T15:08:00Z</published>
    <updated>2020-03-30T15:08:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12602087.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12602087.html" />
    <content type="html">【摘要】前言 AutoWrapper是一个简单可自定义全局异常处理程序和ASP.NET Core API响应的包装。他使用ASP.NET Core middleware拦截传入的HTTP请求，并将最后的结果使用统一的格式来自动包装起来.目的主要是让我们更多的关注业务特定的代码要求，并让包装器自动处理HTTP &lt;a href="http://www.cnblogs.com/yyfh/p/12602087.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12601439.html</id>
    <title type="text">TypeScript数据类型 - HueiFeng</title>
    <summary type="text">TypeScript的原始数据类型 String Number boolean null undefined enum symbol // Number var num:number=1; // 整数 num = 2.5; // 小数 num = 0xf00d; // 十六进制 num = 0b01</summary>
    <published>2020-03-30T13:37:00Z</published>
    <updated>2020-03-30T13:37:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12601439.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12601439.html" />
    <content type="html">【摘要】TypeScript的原始数据类型 String Number boolean null undefined enum symbol // Number var num:number=1; // 整数 num = 2.5; // 小数 num = 0xf00d; // 十六进制 num = 0b01 &lt;a href="http://www.cnblogs.com/yyfh/p/12601439.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12593638.html</id>
    <title type="text">TypeScript环境搭建 - HueiFeng</title>
    <summary type="text">前言 TypeScript是微软开发的一门自由和开源的编程语言,TypeScript是JavaScript的一个超集，他保留JavaScript语言本身的特性,同时他向我们提供了一些语法糖帮助我们方便更好的实践面向对象编程。 同时利用他我们可以使JavaScript开发变得更简单，同时他更符合前端模</summary>
    <published>2020-03-29T09:40:00Z</published>
    <updated>2020-03-29T09:40:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12593638.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12593638.html" />
    <content type="html">【摘要】前言 TypeScript是微软开发的一门自由和开源的编程语言,TypeScript是JavaScript的一个超集，他保留JavaScript语言本身的特性,同时他向我们提供了一些语法糖帮助我们方便更好的实践面向对象编程。 同时利用他我们可以使JavaScript开发变得更简单，同时他更符合前端模 &lt;a href="http://www.cnblogs.com/yyfh/p/12593638.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12515229.html</id>
    <title type="text">ASP.NET 开源导入导出库Magicodes.IE 完成Excel图片导入导出 - HueiFeng</title>
    <summary type="text">Magicodes.IE Excel图片导入导出 为了更好的根据实际功能来迭代，从2.2的里程碑规划开始，我们将结合社区的建议和意见来进行迭代，您可以点此链接来提交您的意见和建议： https://github.com/dotnetcore/Magicodes.IE/issues/46 说明 本章教</summary>
    <published>2020-03-18T00:14:00Z</published>
    <updated>2020-03-18T00:14:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12515229.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12515229.html" />
    <content type="html">【摘要】Magicodes.IE Excel图片导入导出 为了更好的根据实际功能来迭代，从2.2的里程碑规划开始，我们将结合社区的建议和意见来进行迭代，您可以点此链接来提交您的意见和建议： https://github.com/dotnetcore/Magicodes.IE/issues/46 说明 本章教 &lt;a href="http://www.cnblogs.com/yyfh/p/12515229.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
  <entry>
    <id>http://www.cnblogs.com/yyfh/p/12508844.html</id>
    <title type="text">【翻译】.NET 5 Preview 1 发布 - HueiFeng</title>
    <summary type="text">.NET 5 Preview 1 发布 去年年底,我们发布了.NET Core 3.0和3.1.这些版本添加了桌面应用程序模型Windows Forms(WinForms)和WPF,ASP.NET Blazor用于构建SPA应用程序和用于构建分布式应用和服务的gRPC模板、用于与gRPC对话丰富的客</summary>
    <published>2020-03-17T02:01:00Z</published>
    <updated>2020-03-17T02:01:00Z</updated>
    <author>
      <name>HueiFeng</name>
      <uri>http://www.cnblogs.com/yyfh/</uri>
    </author>
    <link rel="alternate" href="http://www.cnblogs.com/yyfh/p/12508844.html" />
    <link rel="alternate" type="text/html" href="http://www.cnblogs.com/yyfh/p/12508844.html" />
    <content type="html">【摘要】.NET 5 Preview 1 发布 去年年底,我们发布了.NET Core 3.0和3.1.这些版本添加了桌面应用程序模型Windows Forms(WinForms)和WPF,ASP.NET Blazor用于构建SPA应用程序和用于构建分布式应用和服务的gRPC模板、用于与gRPC对话丰富的客 &lt;a href="http://www.cnblogs.com/yyfh/p/12508844.html" target="_blank"&gt;阅读全文&lt;/a&gt;</content>
  </entry>
</feed>