<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="java是纯粹的面向对象的语言 也就是万事万物皆是对象 程序是对象的集合,他们通过发送消息来相互通信 每个对象都有自己的由其他的对象所构建的存储,也就是对象可以包含对象 每个对象都有它的类型 也就是类" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>-1-2 java 面向对象基本概念       封装继承多态 变量 this super  static 静态变量 匿名对象 值传递 初始化过程 代码块 final关键字 抽象类 接口 区别 多态  包 访问权限 内部类 匿名内部类 == 与 equal - noteless - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=BKtyzabbeYJEVOaELkxmRjHbp7LT-v37GzrU5S24bJk" />
    <link id="MainCss" rel="stylesheet" href="/skins/buildtowin/bundle-buildtowin.min.css?v=lp23bZd4RUCf9TGsihJRLSq5M_182P4N8YRMn1A2CWo" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/noteless/custom.css?v=fnk17ixpiOajP7an/OE6hUwN1aI=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/buildtowin/bundle-buildtowin-mobile.min.css?v=ADiCwO2hOTdd5yYidcx7eob7ix2VJI4o_TXjEycTHjs" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/noteless/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/noteless/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/noteless/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=wKnarAbt-YO5waLYR80IqCLKpzPpF-s-32JKmKCtJxg"></script>
    <script>
        var currentBlogId = 268100;
        var currentBlogApp = 'noteless';
        var cb_enable_mathjax = true;
        var isLogined = false;
        var skinName = 'BuildtoWin';
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <link rel="stylesheet" href="https://blog-static.cnblogs.com/files/noteless/cnblogs.css" type="text/css" />

<!--
<link rel="stylesheet" href="https://blog-static.cnblogs.com/files/noteless/monokai-sublime.css">
-->

<script src="https://blog-static.cnblogs.com/files/noteless/highlight.pack.js" defer></script>






<div class="main-top">

  <a class="avatar" href="https://www.cnblogs.com/noteless">
    <img src="//files.cnblogs.com/files/noteless/cnblogspic2.gif" alt="noteless 头像">
</a>
<div class="title">
    <a class="name" href="https://www.cnblogs.com/noteless/">noteless</a>
  </div>
<div class="info">

  </div>
</div>



<a href="#"><div id="toTop" style="zoom:0;display:none"></div></a>
    </div>
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/noteless/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/noteless/">noteless</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/noteless/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/noteless">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/noteless/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
212&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
89</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/noteless/p/9260289.html">-1-2 java 面向对象基本概念       封装继承多态 变量 this super  static 静态变量 匿名对象 值传递 初始化过程 代码块 final关键字 抽象类 接口 区别 多态  包 访问权限 内部类 匿名内部类 == 与 equal</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    <p><span style="font-size: medium;">java是纯粹的面向对象的语言</span></p>
<p><span style="font-size: medium;">也就是万事万物皆是对象</span></p>
<p><span style="font-size: medium;">程序是对象的集合,他们通过发送消息来相互通信</span></p>
<p><span style="font-size: medium;">每个对象都有自己的由其他的对象所构建的存储,也就是对象可以包含对象</span></p>
<p><span style="font-size: medium;">每个对象都有它的类型&nbsp; 也就是类</span></p>
<p><span style="font-size: medium;">某一特定类型的所有对象都可以接收相同的消息,因为同一类事物有共同的特性</span></p>
<hr />
<p><span style="font-size: medium;">面向对象开发</span></p>
<p><span style="font-size: medium;">&bull;就是不断的创建对象，使用对象，指挥对象做事情。</span></p>
<p><span style="font-size: medium;">面向对象设计</span></p>
<p><span style="font-size: medium;">&bull;其实就是在管理和维护对象之间的关系。</span></p>
<hr />
<p><span style="font-size: medium;">面向对象特征</span></p>
<p><span style="font-size: medium;">&bull;<strong>封装</strong>(encapsulation)</span></p>
<p><span style="font-size: medium;">&bull;<strong>继承</strong>(inheritance)</span></p>
<p><span style="font-size: medium;">&bull;<strong>多态</strong>(polymorphism)</span></p>
<p><span style="font-size: medium;">&nbsp;</span></p>
<p><span style="font-size: medium;">现实应用场景终归是要解决问题,面向过程的语言,是一个方法伴随着另一个方法的调用</span></p>
<p><span style="font-size: medium;">随着应用规模的不断变大,显然软件代码管理变得更加困难</span></p>
<p><span style="font-size: medium;">面向对象把功能逻辑封装到类本身,用对象去调用功能 持有数据,结构更加自然,也更符合人们的思维习惯</span></p>
<p><span style="font-size: medium;">&nbsp;</span></p>
<p><span style="font-size: medium;">也就是说java中类 和对象 是划分逻辑功能的具体单位</span></p>
<p><span style="font-size: medium;">面向对象的语言中,都会有类这个概念,一类事物他们有共同的属性和行为</span></p>
<p><span style="font-size: medium;">java中描述事物通过类的形式体现，类是具体事物的抽象，概念上的定义。</span></p>
<p><span style="font-size: medium;">对象即是该类事物实实在在存在的个体。</span></p>
<p><span style="font-size: medium;">类：是一组相关的属性和行为的集合</span></p>
<p><span style="font-size: medium;">对象：是该类事物的具体体现</span></p>
<p><span style="font-size: medium;">&nbsp;</span></p>
<p><span style="font-size: medium;"><strong>成员变量与局部变量</strong></span></p>
<p><span style="font-size: medium;">在类中的位置不同</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量 类中方法外</span></p>
<p><span style="font-size: medium;">　　&bull;局部变量 方法内或者方法声明上</span></p>
<p><span style="font-size: medium;">在内存中的位置不同</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量 堆内存</span></p>
<p><span style="font-size: medium;">　　&bull;局部变量 栈内存</span></p>
<p><span style="font-size: medium;">生命周期不同</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量 随着对象的存在而存在，随着对象的消失而消失</span></p>
<p><span style="font-size: medium;">　　&bull;局部变量 随着方法的调用而存在，随着方法的调用完毕而消失</span></p>
<p><span style="font-size: medium;">初始化值不同</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量 有默认的初始化值</span></p>
<p><span style="font-size: medium;">　　&bull;局部变量 没有默认的初始化值，必须先定义，赋值，才能使用。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;"><strong>this</strong>:代表所在类的对象引用</span></p>
<p><span style="font-size: medium;">记住：</span></p>
<p><span style="font-size: medium;">&bull;方法被哪个对象调用，this就代表那个对象</span></p>
<p><span style="font-size: medium;">什么时候使用this呢?</span></p>
<p><span style="font-size: medium;">&bull;局部变量隐藏成员变量</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">static关键字</span></strong></p>
<p><span style="font-size: medium;">可以修饰成员变量和成员方法</span></p>
<p><span style="font-size: medium;">static关键字特点</span></p>
<p><span style="font-size: medium;">　　&bull;随着类的加载而加载</span></p>
<p><span style="font-size: medium;">　　&bull;优先于对象存在</span></p>
<p><span style="font-size: medium;">　　&bull;被类的所有对象共享</span></p>
<p><span style="font-size: medium;">　　&bull;这也是我们判断是否使用静态关键字的条件</span></p>
<p><span style="font-size: medium;">　　&bull;可以通过类名调用</span></p>
<p><span style="font-size: medium;">static关键字注意事项</span></p>
<p><span style="font-size: medium;">　　&bull;在静态方法中是没有this关键字的</span></p>
<p><span style="font-size: medium;">　　&bull;静态方法只能访问静态的成员变量和静态的成员方法</span></p>
<p><strong><span style="font-size: medium;">静态变量与成员变量</span></strong></p>
<p><span style="font-size: medium;">所属不同</span></p>
<p><span style="font-size: medium;">　　&bull;静态变量属于类，所以也称为为类变量</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量属于对象，所以也称为实例变量(对象变量)</span></p>
<p><span style="font-size: medium;">内存中位置不同</span></p>
<p><span style="font-size: medium;">　　&bull;静态变量存储于方法区的静态区</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量存储于堆内存</span></p>
<p><span style="font-size: medium;">内存出现时间不同</span></p>
<p><span style="font-size: medium;">　　&bull;静态变量随着类的加载而加载，随着类的消失而消失</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量随着对象的创建而存在，随着对象的消失而消失</span></p>
<p><span style="font-size: medium;">调用不同</span></p>
<p><span style="font-size: medium;">　　&bull;静态变量可以通过类名调用，也可以通过对象调用</span></p>
<p><span style="font-size: medium;">　　&bull;成员变量只能通过对象名调用</span></p>
<p><strong><span style="font-size: medium;">匿名对象</span></strong></p>
<p><span style="font-size: medium;">匿名对象：就是没有名字的对象。</span></p>
<p><span style="font-size: medium;">　　&bull;是对象的一种简化表示形式</span></p>
<p><span style="font-size: medium;">匿名对象的两种使用情况</span></p>
<p><span style="font-size: medium;">　　&bull;对象调用方法仅仅一次的时候</span></p>
<p><span style="font-size: medium;">　　&bull;作为实际参数传递</span></p>
<p><strong><span style="font-size: medium;">值传递</span></strong></p>
<p><span style="font-size: medium;">java中全部都是值传递&nbsp;&nbsp; 引用类型传递的也是值&nbsp; 只不过是地址</span></p>
<p><strong><span style="font-size: medium;">初始化过程</span></strong></p>
<p><span style="font-size: medium;">Student s = new Student();在内存中做了哪些事情?</span></p>
<p><span style="font-size: medium;">　　&bull;加载Student.class文件进内存</span></p>
<p><span style="font-size: medium;">　　&bull;在栈内存为s开辟空间</span></p>
<p><span style="font-size: medium;">　　&bull;在堆内存为学生对象开辟空间</span></p>
<p><span style="font-size: medium;">　　&bull;对学生对象的成员变量进行默认初始化</span></p>
<p><span style="font-size: medium;">　　&bull;对学生对象的成员变量进行显示初始化</span></p>
<p><span style="font-size: medium;">　　&bull;通过构造方法对学生对象的成员变量赋值</span></p>
<p><span style="font-size: medium;">　　&bull;学生对象初始化完毕，把对象地址赋值给s变量</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">封装</span></strong></p>
<p><span style="font-size: medium;">封装概述</span></p>
<p><span style="font-size: medium;">　　&bull;是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</span></p>
<p><span style="font-size: medium;">好处：</span></p>
<p><span style="font-size: medium;">　　&bull;隐藏实现细节，提供公共的访问方式</span></p>
<p><span style="font-size: medium;">　　&bull;提高了代码的复用性</span></p>
<p><span style="font-size: medium;">　　&bull;提高安全性。</span></p>
<p><span style="font-size: medium;">封装原则：</span></p>
<p><span style="font-size: medium;">　　&bull;将不需要对外提供的内容都隐藏起来。</span></p>
<p><span style="font-size: medium;">　　&bull;把属性隐藏，提供公共方法对其访问。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">构造方法</span></strong></p>
<p><span style="font-size: medium;">特点：</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; 1.函数名与类名相同</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size: medium;">2.不用定义返回值类型</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size: medium;">3.没有具体的返回值。</span></p>
<p><span style="font-size: medium;">作用：</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size: medium;">给对象进行初始化。</span></p>
<p><span style="font-size: medium;">注意：</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size: medium;">1.默认构造函数的特点,如果自建将会失去默认,需要的话必须显式</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-size: medium;">2.多个构造函数是以重载的形式存在的。</span></p>
<p><strong><span style="font-size: medium;">代码块</span></strong></p>
<p><span style="font-size: medium;">　　&bull;在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。</span></p>
<p><span style="font-size: medium;">&bull;局部代码块</span></p>
<p><span style="font-size: medium;">　　&bull;在方法中出现；限定变量生命周期，及早释放，提高内存利用率</span></p>
<p><span style="font-size: medium;">&bull;构造代码块</span></p>
<p><span style="font-size: medium;">　　&bull;在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</span></p>
<p><span style="font-size: medium;">&bull;静态代码块 在类中方法外出现，加了static修饰</span></p>
<p><span style="font-size: medium;">　　&bull;在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且值执行一次。</span></p>
<p><span style="font-size: medium;">执行顺序&nbsp;&nbsp; 静态代码块 &gt; 构造代码块 &gt; 构造方法</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">private关键字</span></strong></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)私有的意义，可以修饰成员变量和成员方法</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)特点：</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 被private修饰的后的成员只能在本类中被访问</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)private的应用：</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以后再写一个类的时候：</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把所有的成员变量给private了</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供对应的getXxx()/setXxx()方法</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">继承</span></strong></p>
<p><span style="font-size: medium;">多个类中存在相同属性和行为时，</span></p>
<p><span style="font-size: medium;">将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</span></p>
<p><span style="font-size: medium;">多个类可以称为子类，单独这个类称为父类或者超类。</span></p>
<p><span style="font-size: medium;">子类可以直接访问父类中的非私有的属性和行为。</span></p>
<p><span style="font-size: medium;">通过extends 关键字让类与类之间产生继承关系。</span></p>
<p><span style="font-size: medium;">　　&bull;class SubDemo <strong>extends</strong>Demo{}</span></p>
<p><span style="font-size: medium;">继承的出现提高了代码的复用性。</span></p>
<p><span style="font-size: medium;">继承的出现让类与类之间产生了关系，提供了多态的前提。</span></p>
<p><strong>&nbsp;</strong></p>
<p><span style="font-size: medium;">Java只支持单继承，不支持多继承。</span></p>
<p><span style="font-size: medium;">　　&bull;一个类只能有一个父类，不可以有多个父类。</span></p>
<p><span style="font-size: medium;">　　&bull;class SubDemo extends Demo{} //ok</span></p>
<p><span style="font-size: medium;">　　&bull;class SubDemo extends Demo1,Demo2...//error</span></p>
<p><span style="font-size: medium;">Java支持多层继承(继承体系)</span></p>
<p><span style="font-size: medium;">　　&bull;class A{}</span></p>
<p><span style="font-size: medium;">　　&bull;class B extends A{}</span></p>
<p><span style="font-size: medium;">　　&bull;class C extends B{}</span></p>
<p><span style="font-size: medium;">定义继承需要注意：</span></p>
<p><span style="font-size: medium;">　　&bull;不要仅为了获取其他类中某个功能而去继承</span></p>
<p><span style="font-size: medium;">继承缺点:</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 原则：低耦合，高内聚。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 耦合：类与类的关系</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 内聚：自己完成某件事情的能力</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.打破了封装性</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">super</span></strong></p>
<p><span style="font-size: medium;">this代表本类对象的引用</span></p>
<p><span style="font-size: medium;">&bull;类与类之间要有所属( " is a " )关系，xx1是xx2的一种。</span></p>
<p><span style="font-size: medium;">super代表父类的内存空间的标识。</span></p>
<p><span style="font-size: medium;">当子父类出现同名成员时，可以用super进行区分</span></p>
<p><span style="font-size: medium;">子类要调用父类构造函数时，可以使用super语句。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">方法覆盖 override</span></strong></p>
<p><span style="font-size: medium;">子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为重写或者复写。</span></p>
<p><span style="font-size: medium;">父类中的私有方法不可以被覆盖。</span></p>
<p><span style="font-size: medium;">在子类覆盖方法中，继续使用被覆盖的方法可以通过super.函数名获取。</span></p>
<p><span style="font-size: medium;">覆盖注意事项：</span></p>
<p><span style="font-size: medium;">　　&bull;覆盖时，子类方法权限一定要大于等于父类方法权限</span></p>
<p><span style="font-size: medium;">　　&bull;静态只能覆盖静态。</span></p>
<p><span style="font-size: medium;">覆盖的应用：</span></p>
<p><span style="font-size: medium;">　　&bull;当子类需要父类的功能，而功能主体子类有自己特有内容时，可以复写父类中的方法，</span></p>
<p><span style="font-size: medium;">　　这样，即沿袭了父类的功能，又定义了子类特有的内容。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">子类实例化过程</span></strong></p>
<p><span style="font-size: medium;">子类中所有的构造函数默认都会访问父类中空参数的构造函数</span></p>
<p><span style="font-size: medium;">因为每一个构造函数的第一行都有一条默认的语句super();</span></p>
<p><span style="font-size: medium;">子类会具备父类中的数据，所以要先明确父类是如何对这些数据初始化的。</span></p>
<p><span style="font-size: medium;">当父类中没有空参数的构造函数时，子类的构造函数必须通过this或者super语句指定要访问的构造函数。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">final关键字</span></strong></p>
<p><span style="font-size: medium;">final可以修饰类，方法，变量。</span></p>
<p><span style="font-size: medium;">final修饰的类不可以被继承。</span></p>
<p><span style="font-size: medium;">final修饰的方法不可以被覆盖。</span></p>
<p><span style="font-size: medium;">final修饰的变量是一个常量。只能被赋值一次。</span></p>
<p><span style="font-size: medium;">内部类只能访问被final修饰的局部变量。</span></p>
<p><span style="font-size: 15px;">1,变量</span></p>
<p><span style="font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a:基本类型 值不能发生改变</span></p>
<p><span style="font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的</span></p>
<p><span style="font-size: 15px;">2,初始化时机</span></p>
<p><span style="font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a:只能初始化一次。</span></p>
<p><span style="font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b:常见的给值方式</span></p>
<p><span style="font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 定义的时候。(推荐)</span></p>
<p><span style="font-size: 15px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 构造方法中。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">抽象类</span></strong></p>
<p><span style="font-size: medium;">抽象定义：</span></p>
<p><span style="font-size: medium;">　　&bull;抽象就是从多个事物中将共性的，本质的内容抽取出来。</span></p>
<p><span style="font-size: medium;">抽象类：</span></p>
<p><span style="font-size: medium;">　　&bull;Java中可以定义没有方法体的方法，该方法的具体实现由子类完成，该方法称为抽象方法，</span></p>
<p><span style="font-size: medium;">包含抽象方法的类就是抽象类。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">抽象方法的由来：</span></p>
<p><span style="font-size: medium;">&bull;多个对象都具备相同的功能，但是功能具体内容有所不同</span></p>
<p><span style="font-size: medium;">那么在抽取过程中，只抽取了功能定义，并未抽取功能主体，</span><span style="font-size: medium;">那么只有功能声明，没有功能主体的方法称为抽象方法。</span></p>
<p><span style="font-size: medium;">抽象类和抽象方法必须用abstract关键字来修饰。</span></p>
<p><span style="font-size: medium;">抽象方法只有方法声明，没有方法体，定义在抽象类中。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">&bull;格式：修饰符 abstract 返回值类型 函数名(参数列表) ;</span></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">抽象类不可以被实例化，也就是不可以用new创建对象。原因如下：</span></p>
<p><span style="font-size: medium;">　　&bull;抽象类是具体事物抽取出来的，本身是不具体的，没有对应的实例。</span></p>
<p><span style="font-size: medium;">　　&bull;而且抽象类即使创建了对象，调用抽象方法也没有意义。</span></p>
<p><span style="font-size: medium;">抽象类通过其子类实例化，而子类需要覆盖掉抽象类中所有的抽象方法后才可以创建对象，否则该子类也是抽象类。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">接口</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">格式：</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">　　interface {}</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">接口中的成员修饰符是固定的。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">　　&bull;成员常量：public static final</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">　　&bull;成员函数：public abstract</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">　　&bull;接口中的成员都是public的。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">没有构造方法</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">接口的出现将&ldquo;多继承&rdquo;通过另一种形式体现出来，即&ldquo;多实现&rdquo;。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">接口是对外暴露的规则。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">接口是程序的功能扩展。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">接口的出现降低耦合性。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">接口可以用来多实现。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: 16px;">接口与接口之间可以有继承关系。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">&bull;类实现接口用implements表示</span></p>
<p><span style="font-size: medium;">&bull;格式：</span></p>
<p><span style="font-size: medium;">　　class 类名 implements 接口名 {}</span></p>
<p><span style="font-size: medium;">&bull;接口不能实例化&nbsp;</span><span style="font-size: medium;">那么，接口如何实例化呢?</span></p>
<p><span style="font-size: medium;">　　按照多态的方式，由具体的子类实例化。其实这也是多态的一种，接口多态。</span></p>
<p><span style="font-size: medium;">&bull;接口的子类&nbsp;</span><span style="font-size: medium;">要么是抽象类&nbsp; &nbsp;</span><span style="font-size: medium;">要么重写接口中的所有抽象方法</span></p>
<p><strong>&nbsp;</strong></p>
<p><strong><span style="font-size: medium;">类与类,类与接口以及接口与接口的关系</span></strong></p>
<p><span style="font-size: medium;">类与类</span></p>
<p><span style="font-size: medium;">&bull;继承关系，只能单继承，但是可以多层继承</span></p>
<p><span style="font-size: medium;">类与接口</span></p>
<p><span style="font-size: medium;">&bull;实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口</span></p>
<p><span style="font-size: medium;">接口与接口</span></p>
<p><span style="font-size: medium;">&bull;继承关系，可以单继承，也可以多继承</span></p>
<p><strong>&nbsp;</strong></p>
<p><strong><span style="font-size: medium;">多态</span></strong></p>
<p><span style="font-size: 16px;">某一类事物的多种存在形态</span></p>
<p><span style="font-size: 16px;">程序中体现：</span></p>
<p><span style="font-size: 16px;">　　父类或者接口的引用指向或者接收自己的子类对象。</span></p>
<p><span style="font-size: 16px;">好处和作用：</span></p>
<p><span style="font-size: 16px;">　　多态的存在提高了程序的扩展性和后期可维护性</span></p>
<p><span style="font-size: 16px;">前提：</span></p>
<p><span style="font-size: 16px;">　　&bull;需要存在继承或者实现关系</span></p>
<p><span style="font-size: 16px;">　　&bull;要有覆盖操作</span></p>
<p><span style="font-size: 16px;">　　&bull;有父类或者父接口引用指向子类对象。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">包</span></strong></p>
<p><span style="font-size: medium;">对类文件进行分类管理。</span></p>
<p><span style="font-size: medium;">给类提供多层命名空间。</span></p>
<p><span style="font-size: medium;">写在程序文件的第一行。</span></p>
<p><span style="font-size: medium;">类名的全称的是 <strong>包名.类名</strong>。</span></p>
<p><span style="font-size: medium;">包也是一种封装形式。</span></p>
<p><span style="font-size: medium;">定义包的格式</span></p>
<p><span style="font-size: medium;">　　&bull;package 包名;</span></p>
<p><span style="font-size: medium;">　　&bull;多级包用.分开即可</span></p>
<p><span style="font-size: medium;">注意事项：</span></p>
<p><span style="font-size: medium;">　　&bull;package语句必须是程序的第一条可执行的代码</span></p>
<p><span style="font-size: medium;">　　&bull;package语句在一个java文件中只能有一个</span></p>
<p><span style="font-size: medium;">　　&bull;如果没有package，默认表示无包名</span></p>
<p><span style="font-size: medium;">&nbsp;</span></p>
<p><span style="font-size: medium;"><img src="https://images2018.cnblogs.com/blog/897393/201807/897393-20180703194714016-1163614021.png" alt="" /></span></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">类：</span></p>
<p><span style="font-size: medium;">　　&bull;默认default，public，final，abstract</span></p>
<p><span style="font-size: medium;">　　&bull;我们自己定义：public居多</span></p>
<p><span style="font-size: medium;">成员变量：</span></p>
<p><span style="font-size: medium;">　　&bull;四种权限修饰符均可,final,static</span></p>
<p><span style="font-size: medium;">　　&bull;我们自己定义：private居多</span></p>
<p><span style="font-size: medium;">构造方法：</span></p>
<p><span style="font-size: medium;">　　&bull;四种权限修饰符均可,其他不可</span></p>
<p><span style="font-size: medium;">　　&bull;我们自己定义：public 居多</span></p>
<p><span style="font-size: medium;">成员方法：</span></p>
<p><span style="font-size: medium;">　　&bull;四种权限修饰符均可，fianl,static,abstract</span></p>
<p><span style="font-size: medium;">　　&bull;我们自己定义：public居多</span></p>
<p><strong>&nbsp;</strong></p>
<p><strong>&nbsp;</strong></p>
<p><strong><span style="font-size: medium;">import</span></strong></p>
<p><span style="font-size: medium;">简化类名。</span></p>
<p><span style="font-size: medium;">一个程序文件中只有一个package，可以有多个import。</span></p>
<p><span style="font-size: medium;">用来导包中的类，不导入包中的包。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">内部类</span></strong></p>
<p><span style="font-size: medium;">将一个类定义在另一个类的里面，对里面那个类就称为内部类（内置类，嵌套类）。</span></p>
<p><span style="font-size: medium;">访问特点：</span></p>
<p><span style="font-size: medium;">　　&bull;内部类可以直接访问外部类中的成员，包括私有成员。</span></p>
<p><span style="font-size: medium;">　　&bull;而外部类要访问内部类中的成员必须要建立内部类的对象。</span></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">成员内部类 局部内部类</span></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">内部类定义在成员位置上</span></p>
<p><span style="font-size: medium;">&bull;可以被private static成员修饰符修饰。</span></p>
<p><span style="font-size: medium;">&bull;被static修饰的内部类只能访问外部类中的静态成员。</span></p>
<p><span style="font-size: medium;">成员内部类不是静态的：</span></p>
<p><strong><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 外部类名.内部类名 对象名 = 外部类名.new 内部类名();</span></strong></p>
<p><span style="font-size: medium;">成员内部类是静态的：</span></p>
<p><strong><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 外部类名.内部类名 对象名 = new 外部类名.内部类名();</span></strong></p>
<p>&nbsp;</p>
<p><span style="font-size: medium;">内部类定义在局部位置上</span></p>
<p><span style="font-size: medium;">&bull;也可以直接访问外部类中的成员。</span></p>
<p><span style="font-size: medium;">&bull;同时可以访问所在局部中的局部变量，但必须是被final修饰的。</span></p>
<p><span style="font-size: medium;">内部类访问外部类属性 <strong>外部类名称.this.属性名</strong></span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">匿名内部类</span></strong></p>
<p><span style="font-size: medium;">就是内部类的简化写法。</span></p>
<p><span style="font-size: medium;">前提：</span></p>
<p><span style="font-size: medium;">　　&bull;内部类可以继承或实现一个外部类或者接口。</span></p>
<p><span style="font-size: medium;">格式为：</span></p>
<blockquote>
<p>　　&bull;new外部类名或者接口名(){</p>
<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;覆盖类或者接口中的代码，(也可以自定义内容。)</p>
<p>　　}</p>
</blockquote>
<p><span style="font-size: medium;">简单理解：</span></p>
<p><span style="font-size: medium;">　　&bull;就是建立一个带内容的外部的类或者接口的子类匿名对象。</span></p>
<p>&nbsp;</p>
<p><strong><span style="font-size: medium;">Object类</span></strong></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (2)Object类的构造方法有一个，并且是无参构造</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (3)要掌握的方法：</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toString()</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 返回对象的字符串表示，默认是由类的全路径+'@'+哈希值的十六进制表示。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这个表示其实是没有实际意义的，一般子类都会重写该方法。</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equals()</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 比较两个对象是否相同。默认情况下，比较的是地址值是否相同。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而比较地址值是没有意义的，所以，一般子类也会重写该方法。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (4)要了解的方法：</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;hashCode() 返回对象的哈希值。不是实际地址值，可以理解为地址值。</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getClass() 返回对象的字节码文件对象</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalize() 用于垃圾回收，在不确定的时间</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clone() 可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5)两个注意问题；</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 直接输出一个对象名称，其实默认调用了该对象的toString()方法。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==和equals()的区别?</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;==</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 基本类型：比较的是值是否相同</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 引用类型：比较的是地址值是否相同</span></p>
<p><span style="font-size: medium;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;equals()</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 只能比较引用类型。默认情况下，比较的是地址值是否相同。</span></p>
<p><span style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是，我们可以根据自己的需要重写该方法。</span></p>
<p>&nbsp;</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2018-07-03 19:40</span>&nbsp;
<a href="https://www.cnblogs.com/noteless/">noteless</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=9260289" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(9260289);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 268100, cb_blogApp = 'noteless', cb_blogUserGuid = '2f3ff2be-bdda-e511-9fc1-ac853d9f53cc';
    var cb_entryId = 9260289, cb_entryCreatedDate = '2018-07-03 19:40', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 noteless
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <script>
/*
$(document).ready(function() {
  $('pre').each(function(i, e) {hljs.highlightBlock(e)});
});
*/
</script>





<script>




//初始化加载函数
$(function(){
    // hideIndexArticle();
    appendNavigator();

    addOriginURL();

addSupport();
hideToTop();


})


//隐藏首页除置顶外的其他所有文章列表
function hideIndexArticle(){
    var windowURL = window.location.href;
    console.log(windowURL )
    if(windowURL && windowURL.indexOf('www.cnblogs.com/noteless')>0 && windowURL.indexOf('html')<0){
        //$('#mainContent .day:not(:first)').css('display','none');
    }
}

//增导航条上增加 目录索引按钮
function appendNavigator(){
    var _html='<li>'
        +'<a id="blog_nav_admin" class="menu" rel="nofollow" href="https://www.cnblogs.com/noteless/p/9400742.html">'
        +'目录索引'
        +'</a>'
        +'</li>';

    $('#navList').append(_html);
}

function appendMenuItem(tagName,id,content){
    console.log(tagName+" "+tagName.substring(1));
    var paddingLeft = tagName.substring(1) * 30; //添加标题缩进
    $('#menu_nav_ol').append('<li class="' + id +'" style="padding-left: '+ paddingLeft +'px;"><b>' + content + '</b></li>');
}


//添加支持一下，请求关注
function addSupport(){

var zhichiHml = '<p>'
+'<span>'
+'<img src="https://files-cdn.cnblogs.com/files/noteless/zhichiyixaa.bmp" alt="">'
+'</span>'
+'</p>';
$('#cnblogs_post_body').append(zhichiHml );

}

//每篇文章增加原文地址
function addOriginURL(){

    //文章增加原文地址
    var originURL='<div>'
        +'原文地址:'
        +'<a href="'
        +window.location.href
        +'" target="_blank">'
        +$('.postTitle a').html()
        +'</a>'
        +'</div>';
		
	originURL+='<img src="https://blog-static.cnblogs.com/files/noteless/%E4%BA%8C%E7%BB%B4%E7%A0%812.gif"></img>';
		
		
    if($("#cnblogs_post_body h3:first").length>0){
        $("#cnblogs_post_body h3:first").before(originURL);
    }else{
        $('#cnblogs_post_body').prepend(originURL);
    }


}

//如果是pc展示返回顶部
function hideToTop(){

	if(isPC()){
		$('#toTop').show();
	}
}


//判断手机还是pc
function isPC() {
   var userAgentInfo = navigator.userAgent;
   var Agents = ["Android", "iPhone",
      "SymbianOS", "Windows Phone",
      "iPad", "iPod"];
   var flag = true;
   for (var v = 0; v < Agents.length; v++) {
      if (userAgentInfo.indexOf(Agents[v]) > 0) {
         flag = false;
         break;
      }
   }
   return flag;
}



//根据标题生成左侧边栏的目录树
// 生成目录开始

$(function () {

	//如果是手机隐藏目录
	if(isPC()){

		//内容拼接
		$('body').append(
			'<div id="article-outline">'
			+'<div style="height:15px;">'
			+'<button type="button" class="close" data-dismiss="modal" aria-hidden="true">'
			+'X'
			+'</button>'
			+'</div>'
			+'</div>'
			+'<style>'
			+'#article-outline{'
			+'display:none;'
			+'min-width:140p;'
			+'max-width: 230px;'
			//+'max-height: 350px;'
			+'position:absolute;'
			+'float: left;'
			+'top:150px;'
			+'left:-999px;'
			+'border:1px solid #ccc;'
			+'box-shadow:5px 5px 2px #ccc;'
			+'padding: 5px 10px;'
			+'background-color: #fff;'
			+'overflow-y: auto;'
			+'scroll-x: auto;'
			+'}'

			+'#article-outline ul{'
			+'margin:5px 0 5px 0;'
			+'padding-left:30px;'
			+'font-size:12px;'
			+'border-left:1px dotted #ccc;'
			+'}'

			+'#article-outline ul:first-child{'
			+'padding-left:15px;'
			+'border:none;'
			+'}'

			+'#article-outline li{'
			+'list-style-type:decimal;'
			+'margin:3px 0;'
			+'}'

			+'#article-outline a{'
			+'color:#00C1E4;'
			+'}'
			+'</style>'
		)
		
		

		
		
		//取得新添加的目录元素
		var jOutline = $('#article-outline');

		//获取文章内容
		//var jContent = $('article .content');
		var jContent = $('div#topics');

		//计算高度
		var jContentHeight = jContent.height();

		//关闭按钮
		jOutline.find('.close').on('click', function () {
			jOutline.hide();
		})

		updateOutline();

		var top = jOutline.offset().top;
		scrollOutline();
		$(window).on('scroll', scrollOutline);

		function scrollOutline() {
			var scrollTop = $(document).scrollTop();
			var maxTop = jContent.offset().top + jContent.height() - jOutline.height();
			//设置行内样式
			if (scrollTop >= top && scrollTop <= maxTop) {
				jOutline.css({'position': 'fixed', 'top': 0});
			}
			else if (scrollTop < top) {
				/*
							jOutline.css({'position': 'absolute','float':'left', 'top': '150px'});
				*/
				jOutline.css({'position': 'absolute', 'top': '200px'});
			}
			else {
				/*
							jOutline.css({'position': 'absolute','float':'left', 'top': maxTop + 'px'});
				*/
				jOutline.css({'position': 'absolute', 'top': maxTop + 'px'});
			}

		}

		function updateOutline() {
			//设置哪些级别的目录
			// var arrAllHeader = jContent.find("h1,h2,h3,h4,h5,h6");
			var arrAllHeader = jContent.find("h2,h3,h4,h5,h6");
			var arrOutline = ['<ul>'];
			var header, headerText;
			var id = 0;
			var level = 0,
				lastLevel = 1;
			var levelCount = 0;
			for (var i = 0, c = arrAllHeader.length; i < c; i++) {
				header = arrAllHeader[i];
				headerText = $(header).text();

				header.setAttribute('id', id);

				level = header.tagName.match(/^h(\d)$/i)[1];
				levelCount = level - lastLevel;

				if (levelCount > 0) {
					for (var j = 0; j < levelCount; j++) {
						arrOutline.push('<ul>');
					}
				} else if (levelCount < 0) {
					levelCount *= -1;
					for (var j = 0; j < levelCount; j++) {
						arrOutline.push('</ul>');
					}
				}
				;
				arrOutline.push('<li>');
				arrOutline.push('<a href="#' + id + '">' + headerText + '</a>');
				arrOutline.push('</li>');
				lastLevel = level;
				id++;
			}
			arrOutline.push('</ul>')
			if (arrOutline.length > 2) {
				jOutline.append(arrOutline.join(''));
				jOutline.find('ul').each(function (i, n) {
					var jThis = $(this);
					if (jThis.children('li').length === 0) {
						jThis.replaceWith(jThis.children());
					}
				});
				showOutline();
			}
			else {
				hideOutline();
			}
		}

		function showOutline() {
			var offset = jContent.offset();

			//目录左侧偏移量
			/*        jOutline.css({
						left: offset.left + jContent.width() + 10 + 'px',
					}).show();*/
			jOutline.css({
				left:8 + 'px',
			}).show();
		}

		function hideOutline() {
			jOutline.hide();
		}
	
	
	}




    
});

//生成目录结束




</script>
    </div>
</body>
</html>