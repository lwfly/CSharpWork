<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="上面这个段子估计很多朋友都看过，程序员被黑过无数次，在其他人眼中，仿佛我们需要写得了木马，翻得了围墙，修得了电脑，找得到资源，但凡是跟计算机沾点边的，咱都得会才行。 段子归段子，言归正传，对于咱们程序" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>一网打尽！每个程序猿都该了解的黑客技术大汇总 - 轩辕之风 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=Z9Vw4btcgJmrpUEjY_SgebmTmDXJ_hPFoST7ad2aJp4" />
    <link id="MainCss" rel="stylesheet" href="/skins/codinglife/bundle-codinglife.min.css?v=hlpQ1CJDwwJXDxv2HNauUmW3NjyWzoMaw1uER19SLT0" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/xuanyuan/custom.css?v=1KFqgc8N4u9cFrFdaEZzuOblzkw=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/codinglife/bundle-codinglife-mobile.min.css?v=XjHfryC9ctsatIZz1dHn7TsRIqmwz9c3aj_6SCfHSDM" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/xuanyuan/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/xuanyuan/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/xuanyuan/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=98Fvfd6UZH20B_MF08daNaODjSu879MVR9RHmyvWAlg"></script>
    <script>
        var currentBlogId = 193695;
        var currentBlogApp = 'xuanyuan';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'CodingLife';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <script>loadPageBeginHtml();</script>
    </div>
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/xuanyuan/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/xuanyuan/">轩辕之风</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/xuanyuan/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E8%BD%A9%E8%BE%95%E4%B9%8B%E9%A3%8E">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/xuanyuan/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
42&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
220</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/xuanyuan/p/12529598.html">一网打尽！每个程序猿都该了解的黑客技术大汇总</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <p><img src="https://imgkr.cn-bj.ufileos.com/c51672e5-63bf-4848-8857-a009bba7aab8.png" alt=""></p>
<p>上面这个段子估计很多朋友都看过，程序员被黑过无数次，在其他人眼中，仿佛我们需要写得了木马，翻得了围墙，修得了电脑，找得到资源，但凡是跟计算机沾点边的，咱都得会才行。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/0f50931f-bedf-4c1c-9345-24e0a61fccd5.png" alt=""></p>
<p>段子归段子，言归正传，对于咱们程序员来说，多多少少了解一些信息安全的技术知识还是大有裨益的，不仅能了解一些计算机和网络的底层原理，也能反哺我们的开发工作，带着安全思维编程，减少漏洞的产生。</p>
<p>本文内容：</p>
<pre><code>- 网络安全
  - SQL注入
  - XSS攻击
  - CSRF攻击
  - DDoS攻击
  - DNS劫持
  - TCP劫持
  - 端口扫描技术
- 系统安全
  - 栈溢出攻击
  - 整数溢出攻击
  - 空指针攻击
  - 释放后使用攻击
  - HOOK
  - 权限提升
  - 可信计算
- 密码学
  - 对称加密 &amp; 非对称加密
  - 秘钥交换技术
  - 信息摘要算法
  - 数据编码技术
  - 多因子认证技术
</code></pre>
<p>信息安全大体可分为三个大的分支：</p>
<ul>
<li><strong>网络安全</strong></li>
<li><strong>系统安全</strong></li>
<li><strong>密码学</strong></li>
</ul>
<p>下面轩辕君就这三个领域分别罗列一些常用的黑客技术，部分技术是存在领域交叉的，就将其划入主要那个类别里去了。</p>
<h1 id="网络安全">网络安全</h1>
<h2 id="sql注入">SQL注入</h2>
<p>Web安全三板斧之首，大名鼎鼎的SQL注入。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/fd6c6b6a-35ed-4901-8cd2-0b8626c2f4e9.png" alt=""></p>
<p><strong>SQL注入攻击的核心在于让Web服务器执行攻击者期望的SQL语句，以便得到数据库中的感兴趣的数据或对数据库进行读取、修改、删除、插入等操作，达到其邪恶的目的。</strong></p>
<p>而如何让Web服务器执行攻击者的SQL语句呢？SQL注入的常规套路在于将SQL语句放置于Form表单或请求参数之中提交到后端服务器，后端服务器如果未做输入安全校验，直接将变量取出进行数据库查询，则极易中招。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/abb55cb8-2f14-4d58-9f98-1b7b6a7906d5.png" alt=""></p>
<p>举例如下：</p>
<p>对于一个根据用户ID获取用户信息的接口，后端的SQL语句一般是这样：</p>
<pre><code class="language-SQL">select name,[...] from t_user where id=$id
</code></pre>
<p>其中，<code>$id</code>就是前端提交的用户id，而如果前端的请求是这样：</p>
<pre><code>GET xx/userinfo?id=1%20or%201=1
</code></pre>
<p>其中请求参数id转义后就是<code>1 or 1=1</code>，如果后端不做安全过滤直接提交数据库查询，SQL语句就变成了：</p>
<pre><code class="language-SQL">select name,[...] from t_user where id=1 or 1=1
</code></pre>
<p>其结果是把用户表中的所有数据全部查出，达到了黑客泄露数据的目的。</p>
<p>以上只是一个极简单的示例，在真实的SQL注入攻击中参数构造和SQL语句远比这复杂得多，不过原理是一致的。<br>
<img src="https://imgkr.cn-bj.ufileos.com/f19e9a0b-1a25-4389-b273-94f6dfc7f675.svg" alt=""></p>
<p><code>防御手段</code>：对输入进行检测，阻断带有SQL语句特征对输入</p>
<p><code>重点关注</code>：<strong>前端工程师</strong>、<strong>Web后端工程师</strong></p>
<h2 id="xss攻击">XSS攻击</h2>
<p>Web安全三板斧之二，全称跨站脚本攻击（Cross Site Scripting），为了与重叠样式表CSS区分，换了另一个缩写XSS。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/8161c9f0-d392-47e5-a1c9-fdd9b95fca2c.png" alt=""></p>
<p>XSS攻击的核心是将可执行的前端脚本代码（一般为JavaScript）植入到网页中，听起来比较拗口，用大白话说就是攻击者想让你的浏览器执行他写的JS代码。那如何办到呢？一般XSS分为两种：</p>
<h3 id="反射型">反射型</h3>
<p><img src="https://imgkr.cn-bj.ufileos.com/aeb8d151-a67a-4d1a-8b55-8f0c2615f64a.png" alt=""></p>
<p>1、攻击者将JS代码作为请求参数放置URL中，诱导用户点击<br>
示例：</p>
<pre><code>http://localhost:8080/test?name=&lt;script&gt;alert(&quot;you are under attack!&quot;)&lt;/script&gt;
</code></pre>
<p>2、用户点击后，该JS作为请求参数传给Web服务器后端</p>
<p>3、后端服务器没有检查过滤，简单处理后放入网页正文中返回给浏览器</p>
<p>4、浏览器解析返回的网页，中招！</p>
<h3 id="存储型">存储型</h3>
<p><img src="https://imgkr.cn-bj.ufileos.com/8b580eb6-9a0f-4585-94b6-72eab76af2cf.png" alt=""></p>
<p>上述方式攻击脚本直接经服务器转手后返回浏览器触发执行，<strong>存储型与之的区别在于能够将攻击脚本入库存储</strong>，在后面进行查询时，再将攻击脚本渲染进网页，返回给浏览器触发执行。常见的套路举例如下：</p>
<p>1、攻击者网页回帖，帖子中包含JS脚本</p>
<p>2、回帖提交服务器后，存储至数据库</p>
<p>3、其他网友查看帖子，后台查询该帖子的回帖内容，构建完整网页，返回浏览器</p>
<p>4、该网友浏览器渲染返回的网页，中招！</p>
<p><code>防御手段</code>：前后端均需要做好内容检测，过滤掉可执行脚本的侵入</p>
<p><code>重点关注</code>：<strong>前端工程师</strong>、<strong>Web后端工程师</strong></p>
<h2 id="csrf攻击">CSRF攻击</h2>
<p>Web安全三板斧之三，攻击示意图如下：</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/d09c653a-9d3b-4cee-a708-4fe7aeec27a2.png" alt=""></p>
<p>核心思想在于，在打开A网站的情况下，另开Tab页面打开恶意网站B，此时在B页面的“唆使”下，浏览器发起一个对网站A的HTTP请求。<br>
这个过程的危害在于2点：</p>
<p>1、这个HTTP请求不是用户主动意图，而是B“唆使的”，如果是一个危害较大的请求操作（发邮件？删数据？等等）那就麻烦了</p>
<p>2、因为之前A网站已经打开了，浏览器存有A下发的Cookie或其他用于身份认证的信息，这一次被“唆使”的请求，将会自动带上这些信息，A网站后端分不清楚这是否是用户真实的意愿</p>
<p><code>重点关注</code>：<strong>前端工程师</strong>、<strong>Web后端工程师</strong></p>
<h2 id="ddos攻击">DDoS攻击</h2>
<p>DDoS全称Distributed Denial of Service：分布式拒绝服务攻击。是拒绝服务攻击的升级版。<br>
拒绝攻击服务顾名思义，让服务不可用。常用于攻击对外提供服务的服务器，像常见的：</p>
<ul>
<li>Web服务</li>
<li>邮件服务</li>
<li>DNS服务</li>
<li>即时通讯服务</li>
<li>......</li>
</ul>
<p><img src="https://imgkr.cn-bj.ufileos.com/d0ceedd8-7d2c-41e7-a387-05af7270b5d4.png" alt=""></p>
<p>在早期互联网技术还没有那么发达的时候，发起DoS攻击是一件很容易的事情：一台性能强劲的计算机，写个程序多线程不断向服务器进行请求，服务器应接不暇，最终无法处理正常的请求，对别的正常用户来说，看上去网站貌似无法访问，拒绝服务就是这么个意思。</p>
<p>后来随着技术对发展，现在的服务器早已不是一台服务器那么简单，你访问一个www.baidu.com的域名，背后是数不清的CDN节点，数不清的Web服务器。</p>
<p>这种情况下，还想靠单台计算机去试图让一个网络服务满载，无异于鸡蛋碰石头，对方没趴下，自己先趴下了。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/699e7365-af5b-463c-b055-78d8d47f43d7.png" alt=""></p>
<p>技术从来都是一柄双刃剑，分布式技术既可以用来提供高可用的服务，也能够被攻击方用来进行大规模杀伤性攻击。攻击者不再局限于单台计算机的攻击能力，转而通过成规模的网络集群发起拒绝服务攻击。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/9af7df1a-d5c5-41f4-8711-26a9233d39d5.png" alt=""></p>
<p>拒绝服务攻击实际上是一类技术，根据具体实施手段的不同，又可以进一步细分：</p>
<ul>
<li>SYN Flood</li>
<li>ICMP Flood</li>
<li>UDP Flood</li>
<li>......</li>
</ul>
<p><code>防御手段</code>：即便是到现在，面对DDoS也没有100%打包票的防御方法，只能靠一些缓解技术一定层面上减轻攻击的威力。这些技术包括：<code>流量清洗</code>、<code>SYN Cookie</code>等等。</p>
<p><code>重点关注</code>：<strong>运维工程师</strong>、<strong>安全工程师</strong></p>
<h2 id="dns劫持">DNS劫持</h2>
<p>当今互联网流量中，以HTTP／HTTPS为主的Web服务产生的流量占据了绝大部分。Web服务发展的如火如荼，这背后离不开一个默默无闻的大功臣就是域名解析系统：</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/4dc4bee8-8f36-4051-b514-07a2569d109c.png" alt=""></p>
<p>如果没有DNS，我们上网需要记忆每个网站的IP地址而不是他们的域名，这简直是灾难，好在DNS默默在背后做了这一切，我们只需要记住一个域名，剩下的交给DNS来完成吧。</p>
<p>也正是因为其重要性，别有用心的人自然是不会放过它，DNS劫持技术被发明了出来。</p>
<p>DNS提供服务用来将域名转换成IP地址，然而在早期协议的设计中并没有太多考虑其安全性，对于查询方来说：</p>
<ul>
<li><strong>我去请求的真的是一个DNS服务器吗？是不是别人冒充的？</strong></li>
<li><strong>查询的结果有没有被人篡改过？这个IP真是这个网站的吗？</strong></li>
</ul>
<p><img src="https://imgkr.cn-bj.ufileos.com/aacac197-0616-498f-b62b-6ebf2e0b6ac3.png" alt=""></p>
<p>DNS协议中没有机制去保证能回答这些问题，因此DNS劫持现象非常泛滥，从用户在地址栏输入一个域名的那一刻起，一路上的凶险防不胜防：</p>
<ul>
<li>本地计算机中的木马修改hosts文件</li>
<li>本地计算机中的木马修改DNS数据包中的应答</li>
<li>网络中的节点（如路由器）修改DNS数据包中的应答</li>
<li>网络中的节点（如运营商）修改DNS数据包中的应答</li>
<li>......</li>
</ul>
<p><img src="https://imgkr.cn-bj.ufileos.com/17cb4cdd-7ba0-444a-96e5-9ca1226641b0.png" alt=""></p>
<p>后来，为了在客户端对收到对DNS应答进行校验，出现了<code>DNSSEC</code>技术，一定程度上可以解决上面的部分问题。但限于一些方面的原因，这项技术并没有大规模用起来，尤其在国内，鲜有部署应用。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/9e28e1fa-54ac-4bd2-a3e7-9e68129d2f93.png" alt=""></p>
<p>再后来，以阿里、腾讯等头部互联网厂商开始推出了<code>httpDNS</code>服务，来了一招釜底抽薪，虽然这项技术的名字中还有<code>DNS</code>三个字母，但实现上和原来但DNS已经是天差地别，通过这项技术让DNS变成了在http协议之上的一个应用服务。</p>
<p><code>重点关注</code>：<strong>安全工程师</strong>、<strong>后端工程师</strong>、<strong>运维工程师</strong></p>
<h2 id="tcp劫持">TCP劫持</h2>
<p><img src="https://imgkr.cn-bj.ufileos.com/f00161f9-2088-455c-abcc-f3e76b4b4003.png" alt=""></p>
<p>TCP是TCP/IP协议族中非常重要的成员，位于传输层。协议本身并没有对TCP传输的数据包进行身份验证，所以我们只要知道一个TCP连接中的seq和ack后就可以很容易的伪造传输包，假装任意一方与另一方进行通信，我们将这一过程称为TCP会话劫持（TCP Session Hijacking）</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/1b8ca477-1ac8-4019-a82d-518ce0a79c16.png" alt=""></p>
<p>TCP劫持技术是一种很老的技术，1995年被提出来后深受黑客青睐。不过近些年来，随着操作系统层面的安全机制增强和防火墙软件的检测能力提升，这种基础的攻击方式越来越容易被发现，慢慢的淡出了人们的视野。</p>
<p><code>重点关注</code>：<strong>安全工程师</strong>、<strong>运维工程师</strong></p>
<h2 id="端口扫描技术">端口扫描技术</h2>
<p>端口扫描是黑客经常使用的一种技术，它一般是作为网络攻击的前期阶段，用于探测目标开启了哪些服务，以便接下来发起针对该服务的攻击。</p>
<p>记得刚刚学习网络安全的时候，大家总会没事拿出工具来扫一扫，虽然扫了之后就没有了下文，也总是乐此不疲，在不懂的人面前秀一把自己的“黑客”能力。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/ebacfa69-9fd0-481c-8493-eec12b0ea4c6.png" alt=""></p>
<p>以TCP／IP协议族构建的互联网，网络服务总是离不开端口这个概念，不管是TCP也好，UDP也罢，应用层都需要一个端口号来进行网络通信。而我们常见的服务端口有：</p>
<ul>
<li><code>21</code>: FTP文件传输服务</li>
<li><code>25</code>: SMTP邮件服务</li>
<li><code>53</code>: DNS域名解析系统服务</li>
<li><code>80</code>: HTTP超文本传输协议服务</li>
<li><code>135</code>: RPC远程过程调用服务</li>
<li><code>443</code>: HTTPS</li>
<li><code>3389</code>: MSRDP微软远程桌面连接服务</li>
<li>......</li>
</ul>
<p>端口扫描都原理，对于基于UDP的服务，发送对应服务都请求包，查看是否有应答；对于基于TCP的服务，尝试发起三次握手发送TCP SYN数据包，查看是否有应答。</p>
<p>如果远端服务器进行了响应，则表明对端服务器上运行了对应的服务，接下来则是进一步探知对端服务器使用的操作系统、运行的服务器程序类型、版本等等，随即针对对应的漏洞程序发起网络攻击。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/312c75c4-cf29-4357-ac4c-c6c175250e63.png" alt=""></p>
<p>由此可见，为安全着想，在互联网上应当尽可能少暴露信息，关闭不需要的服务端口。</p>
<p><code>防御手段</code>：使用防火墙等安全产品，即时发现和阻断非法的扫描探测行为。</p>
<p><code>重点关注</code>：<strong>运维工程师</strong>、<strong>安全工程师</strong></p>
<p><em>[为防抄袭，手动插入文字水印，敬请谅解。本文来自微信公众号：编程技术宇宙]</em></p>
<h2 id=""></h2>
<h1 id="系统安全">系统安全</h1>
<p>系统安全版块中的技术，一般是指攻击发生在终端之上，与操作系统息息相关。</p>
<h2 id="栈溢出攻击">栈溢出攻击</h2>
<p>栈溢出攻击历史悠久，也是发生在系统侧最基础的攻击。</p>
<p>现代计算机基本上都是建立在<code>冯－诺伊曼</code>体系之上，而这一体系有一个最大的问题就是数据和指令都保存在存储器中。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/9d65919f-2241-44ea-94c1-70468e964194.png" alt=""></p>
<p>在计算机的内存中，既包含了程序运行的所有代码指令，又包含了程序运行的输入输出等各种数据，并没有一种强制的机制将指令和数据区分。因为对于计算机来说它们都是一样的二进制0和1，大部分时候都是靠程序按照既定的“规则”去解释理解内存中的这些0和1。而一旦这些“规则”理解错误，事情就变得糟糕起来。</p>
<p>具体到我们现代CPU和OS，不管是x86／x64处理器，还是ARM处理器，均采用了寄存器＋堆栈式的设计，而这个堆栈中，既包含了程序运行各个函数栈帧中的变量数据等信息，还保存了函数调用产生的返回地址。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/eb7302ab-8f25-4e6e-9504-b726dd3e03df.png" alt=""></p>
<p>所谓栈溢出攻击，则是通过一些手段输入到栈中的缓冲区中，冲破缓冲区原有的界限，将存储返回地址的位置覆盖为一个数值，使其指向攻击者提前布置的恶意代码位置，劫持了程序的执行流程。</p>
<p><code>防御手段</code>：现代操作系统针对栈溢出攻击已经有非常成熟的应对方案，像Linux平台的Stack Canary，Windows平台的GS机制等等，程序员需要做的就是充分利用这些机制。</p>
<p><code>重点关注</code>：<strong>C／C++工程师</strong></p>
<h2 id="整数溢出攻击">整数溢出攻击</h2>
<p>和栈溢出攻击一样，整数溢出攻击也是属于溢出类攻击，不一样的是溢出的目标不是栈中的缓冲区，而是一个整数。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/f7ab4083-3b3b-4d18-829c-2572d64d165d.png" alt=""></p>
<p>我们知道，计算机数值以<code>补码</code>的方式表示和存储。在表示一个有符号数时，最高位是用来表示这是一个正数（0）还是一个负数（1），比如对于一个16位的short变量而言，+1和－1的表示方法如下：</p>
<pre><code>+1: 0000 0000 0000 0001
-1: 1111 1111 1111 1111
</code></pre>
<p>一个16位的short变量表示的范围是-32768~32767，现在思考一个问题，假如一个short变量的值现在是32767：</p>
<pre><code>32767: 0111 1111 1111 1111
</code></pre>
<p>如果现在对其执行＋1操作，将变成：</p>
<pre><code>1000 0000 0000 0000
</code></pre>
<p>而这正是-32768的补码形式！</p>
<p>试想一下，如果这个变量名字叫length作为strcpy参数，或是叫index作为数组的下标，整数的溢出将导致可怕的后果，轻则进程崩溃，服务宕机，重则远程代码执行，拿下控制权。</p>
<p><code>重点关注</code>：<strong>所有程序员</strong></p>
<h2 id="空指针攻击">空指针攻击</h2>
<p>空指针一般出现在指针没有初始化，或者使用<code>new</code>进行对象创建/内存分配时失败了，而粗心的程序员并没有检查指针是否为空而进行访问导致的攻击。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/d7ee1c4e-6abd-4980-8ce2-82381d0cbe36.png" alt=""></p>
<p>大多数情况下，这将导致内存地址访问异常，程序会崩溃退出，造成拒绝服务的现象</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/8dd7e2f1-3bd4-4784-8e1f-0fc167556684.png" alt=""></p>
<p>而在一些特殊的情况下，部分操作系统允许分配内存起始地址为0的内存页面，而攻击者如果提前在该页面准备好攻击代码，则可能出现执行恶意代码的风险。</p>
<h2 id="释放后使用攻击">释放后使用攻击</h2>
<p>释放后使用<code>Use After Free</code>意为访问一个已经释放后的内存块。较多的出现在针对浏览器的JavaScript引擎的攻击中。</p>
<p>正常情况下，一个释放后的对象我们是没法再访问的，但如果程序员粗心大意，在delete对象后，没有即时对指针设置为NULL，在后续又继续使用该指针访问对象（比如通过对象的虚函数表指针调用虚函数），将出现内存访问异常。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/119f647f-2fdd-470b-abd9-fb45b46940a4.png" alt=""></p>
<p>在上面的场景中，如果攻击者在delete对象后，马上又new一个同样内存大小的对象，在现代操作系统的堆内存管理算法中，会有很大概率将这个新的对象放置于刚刚被delete的对象的位置处。这个时候还通过原来对象的指针去访问，将出现鸠占鹊巢，出现可怕的后果。</p>
<p>养成好的编程习惯，对象delete后，指针及时置空。</p>
<p><code>重点关注</code>：<strong>C／C++工程师</strong></p>
<h2 id="hook">HOOK</h2>
<p>HOOK原意钩子的意思，在计算机编程中时常用到，用来改变原有程序执行流程。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/37328ed1-6758-446f-aaa1-0c12cf8566a1.png" alt=""></p>
<p>在那个互联网充斥着流氓软件的年代，流行着一种<code>键盘记录器</code>的木马，用于记录用户键盘的输入，从而盗取密码，这其中QQ曾经是重灾区。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/12c93baa-ed86-4ad4-a17f-0d2e0f1addf4.png" alt=""></p>
<p>而实现这一功能的技术就是用到了HOOK技术，钩到了键盘敲击的事件消息。</p>
<p>除了消息HOOK，用得更多的是程序执行流程层面的HOOK。恶意代码被注入目标程序后，在函数入口处添加跳转指令，导致执行到此处的线程转而执行攻击者的代码，实现修改参数、过滤参数的目的。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/45d5b24b-3bff-4ca7-a281-3b15447f3448.png" alt=""></p>
<p>HOOK技术不仅为黑客使用，安全软件用的更多，安全软件需要守护整个系统的安全防线，通过HOOK技术在各处敏感API处设立检查，从而抵御非法调用攻击行为。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/f887922d-3629-40bb-84c5-80f497ecdd42.png" alt=""></p>
<p>另外，软件补丁技术中也时常用到HOOK技术，软件厂商发现原来程序漏洞后，通过HOOK，修改既有程序的执行逻辑，从而达到修复漏洞的目的。</p>
<p><code>重点关注</code>：<strong>C／C++工程师</strong></p>
<h2 id="权限提升">权限提升</h2>
<p>现代操作系统都对运行于其中的进程、线程提供了权限管理，因为安全攻击无可避免，而权限的限制作为一道颇为有效的屏障将程序被攻击后的影响减少到最小。</p>
<p>换句话说，即便我们的程序因为漏洞原因被攻击执行了恶意代码，但因为操作系统的权限控制，恶意代码能干的事情也有限。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/9e6dbb49-a532-40d7-8d21-66cc687d2568.png" alt=""></p>
<p>就像一枚硬币总有两个面，有权限限制，自然而然就有权限提升。攻击者想要做更多事情，就得突破操作系统的限制，获取更高的权限。</p>
<p>在Windows上，经常叫获得管理员权限。</p>
<p>在Linux上，经常叫获得Root权限，手机Root也是这个意思。</p>
<p>在iOS上，经常叫“越狱”。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/9cdca3d5-2891-435a-9417-6ec3d258ad02.png" alt=""></p>
<p>权限提升的方式五花八门，总体来说，程序执行的时候，所属进程／线程拥有一个安全令牌，用以标识其安全等级，在访问资源和执行动作的时候由操作系统内核审核。</p>
<p>权限提升的目标就是将这个安全令牌更改为高等级的令牌，使其在后续访问敏感资源和执行敏感动作时，凭借该令牌可以通过系统的安全审核。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/b959a1ae-445e-4ec8-a13e-81ebf28ff835.png" alt=""></p>
<p>而更改这个安全令牌的惯用伎俩便是利用操作系统内核漏洞（如前面所述的栈溢出、整数溢出、释放后使用等）执行攻击者的代码，实现安全令牌的篡改。</p>
<p><code>重点关注</code>：<strong>安全工程师</strong></p>
<h2 id="可信计算">可信计算</h2>
<p>安全攻击无处不在，不仅应用程序的环境不可靠，甚至连操作系统内核的环境也充满了风险。</p>
<p>如果一段程序（比如支付）必须在一个极度绝密的环境下执行，该怎么办？</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/e0d586d4-7611-4978-97ed-de7a0e46b102.png" alt=""></p>
<p><code>可信计算</code>的概念被安全研究者提了出来，根据百科的解释：</p>
<blockquote>
<p>可信计算/可信用计算（Trusted Computing，TC）是一项由可信计算组（可信计算集群，前称为TCPA）推动和开发的技术。可信计算是在计算和通信系统中广泛使用基于硬件安全模块支持下的可信计算平台，以提高系统整体的安全性 [1]  。签注密钥是一个2048位的RSA公共和私有密钥对，它在芯片出厂时随机生成并且不能改变。这个私有密钥永远在芯片里，而公共密钥用来认证及加密发送到该芯片的敏感数据。</p>
</blockquote>
<p>可信计算中一个非常重要的概念是<code>可信执行环境TEE（Trusted Execution Environment)</code>，简单来说就是在现有的计算机内部的世界里，再构建一个秘密基地，专门用于运行极度机密的程序。该秘密基地甚至连操作系统都轻易无法访问，更别说操作系统之上的应用程序了。</p>
<p>在移动端，ARM芯片占据了主流市场，ARM芯片提供了名为<code>TrustZone</code>技术的技术，在硬件层面新增一个可信计算环境，包含一个可信OS，和一些可信APP，和普通环境在硬件层面隔离，处理器内部进行通信完成两个世界的交互。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/c89ba6e3-e57e-4bf4-af4d-d48e17f5e67c.png" alt=""></p>
<p><code>重点关注</code>：<strong>终端系统工程师</strong></p>
<h1 id="密码学">密码学</h1>
<p>由于数据传输的过程中会遇到信息泄漏、篡改、伪造的风险，加密技术应运而生。</p>
<h2 id="对称加密--非对称加密">对称加密 &amp; 非对称加密</h2>
<p>有加密就有解密，根据加密过程使用的密钥和解密过程使用的密钥是否相同，将加密算法分为了两个大类：<code>对称加密</code>和<code>非对称加密</code>。</p>
<p>最早出现的加密技术是对称加密</p>
<ul>
<li>对称加密：加密密钥和解密密钥一致，特点是加密速度快、加密效率高。常用的对称加密算法有：
<ul>
<li>DES</li>
<li>AES</li>
<li>RC4</li>
</ul>
</li>
</ul>
<p>这种加密方式中有一个非常关键的问题是，解密方需要拿到密钥才能进行解密，而密钥钥匙通过网络传输又会面临不安全的风险，这成了一个鸡生蛋，蛋生鸡的问题。</p>
<p>于是通信技术上一个划时代的技术被发明了出来，这就是<code>非对称加密</code>！</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/3adf773c-0ec9-4924-9fa9-28f1d4dfc783.png" alt=""></p>
<ul>
<li>非对称加密：加密密钥与解密密钥不一致，特点是算法较复杂，但安全性高。非对称加密的密钥一般分为公钥和私钥，公钥公开，私钥需保密。常用于数字认证，如HTTPS中握手阶段的服务器认证。常用的非对称加密算法有：
<ul>
<li>RSA</li>
<li>DH</li>
<li>ECC（椭圆曲线加密）</li>
</ul>
</li>
</ul>
<p>可以毫不夸张的说，没有了非对称加密，互联网绝不会发展到今天这样的高度。</p>
<h2 id="秘钥交换技术">秘钥交换技术</h2>
<p>在互联网通信中，有加密就有解密，解密自然就需要密钥，那如何把这个密钥告诉对方呢？<code>密钥交换算法</code>就是要解决这个问题：如何安全的将密钥传输给对方？</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/98da3b2a-084a-4785-90c6-02d18000ce97.png" alt=""></p>
<p>回头看看上面提到的非对称加密，它就可以解决这个问题：</p>
<ol>
<li>服务器负责生成一对公私钥，公钥告诉客户端，私钥自己保存</li>
<li>客户端拿到公钥后，使用它来对后续通信将要使用的对称加密算法密钥进行加密传输</li>
<li>服务端收到后使用私钥解密，拿到这个密钥</li>
<li>以后双方可以通过对称加密进行传输通信</li>
</ol>
<p>上面这个例子并不只是举例，在早期版本的HTTPS中，就是通过这种方式来进行密钥交换。而后来的版本中，另外一种叫DH及其变种的密钥交换算法用的越来越多。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/f98bf245-c5fc-4c2d-b16a-cb0899edb090.png" alt=""></p>
<p>DH全称Diffie-Hellman，是两位数学家的名称构成，这种算法的核心是完全依靠数学运算实现密钥的交换。</p>
<h2 id="信息摘要算法">信息摘要算法</h2>
<p>信息摘要算法其实不算是一种加密算法，加密的前提是可以通过解密还原，而信息摘要算法的目的并不是对数据进行保护，也无法解密还原。</p>
<p>在一些语境下，信息摘要我们听得少，听的更多的名词是<code>哈希</code></p>
<p>信息摘要算法的目的之一是校验数据的正确性，算法公开，数据通过该算法得出一个摘要值，收到数据后通过该算法计算出这个摘要，前后对比就知道是否有被篡改。</p>
<p>常用的信息摘要算法有：</p>
<ul>
<li>MD5</li>
<li>SHA1</li>
<li>SHA256</li>
</ul>
<h2 id="数据编码技术">数据编码技术</h2>
<p>严格来说，数据编码技术也不算是加密算法，因为其目的同样不是为了加密，而只是为了将数据编码以便传输。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/9bcf89a2-87e6-4dfd-87ee-c6db6ec30198.png" alt=""></p>
<p>最常见的编码算法就是<code>base64</code>了，多用于编码二进制的数据，将不可见的字符编码后转换成64个常见字符组成的文本，便于打印、展示、传输、存储。如邮件eml格式中，将附件文件通过base64编码。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/13c8bb3b-b46c-4319-8690-b7ac28f6adc2.png" alt=""></p>
<p>除了base64，还有常用于比特币钱包地址编码的base58。base家族还有base85、base92、base128等众多算法。它们的区别不仅仅在于参与编码的字符集不同，算法执行也是各有千秋。</p>
<h2 id="多因子认证技术">多因子认证技术</h2>
<p>说到认证，最常出现的莫过于登录、支付等场景。传统的认证技术就是密码技术，但随着网络攻击的日益猖獗以及互联网渗透到人们生活的方方面面，传统密码技术的安全性不足以满足互联网的发展。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/efed2d13-2921-4f63-a8bc-46d50daa5cc5.png" alt=""></p>
<p>多因子认证技术意为在传统密码认证之外，引入其他认证技术进行补充，使用2种及以上的方式共同完成认证。随着人工智能技术的发展，基于生物特征的认证技术突飞猛进：</p>
<ul>
<li>指纹认证</li>
<li>虹膜认证</li>
<li>人脸识别</li>
<li>......</li>
</ul>
<p><img src="https://imgkr.cn-bj.ufileos.com/a2d5d21d-989d-4bb1-9a5f-2763077d2261.png" alt=""></p>
<p>这个世界从来不缺先行者，多因子认证看上去很复杂，好在已经有不少头部企业搭建了认证平台，对于绝大多数企业，需要做的只是下载SDK，调用API而已。</p>
<p>目前国内外主流的多因子认证平台有三大派系：</p>
<ul>
<li>
<p><code>FIDO</code>，国际标准，在国内，翼支付、百度钱包、京东钱包、微众银行等都已经应用<br>
<img src="https://imgkr.cn-bj.ufileos.com/aaab8dcd-bae0-4698-a9db-809ce3e171ac.png" alt=""></p>
</li>
<li>
<p><code>IFAA</code>，阿里系，凭借阿里在电商领域的优势，也吸引了众多追随者。<br>
<img src="https://imgkr.cn-bj.ufileos.com/17bbf070-d073-4a4e-afc9-d972720c3c1e.png" alt=""></p>
</li>
<li>
<p><code>TUSI</code>，腾讯系<br>
<img src="https://imgkr.cn-bj.ufileos.com/9c2ee4a3-7ccf-4eae-a7fe-407e19da36cf.png" alt=""></p>
</li>
</ul>
<h1 id="总结">总结</h1>
<p>本文罗列了一些常见的信息安全技术，主要分网络安全、系统安全和密码学三个领域展开。</p>
<p>信息安全技术不仅仅是安全工程师的事情，作为一位程序员，了解这些技术将帮助我们更好的<code>Build The World</code>！</p>
<p>知识在于分享，转发这篇文章，让更多的人看到。</p>
<h2 id="往期热门回顾">往期热门回顾</h2>
<p><a href="https://mp.weixin.qq.com/s/Bb2ugXYPR6r11QaGKbNBSw">看过无数Java GC文章，这5个问题你也未必知道！</a></p>
<p><a href="https://mp.weixin.qq.com/s/BEYQF305cWAOIwK2DtvyfQ">Python一键转Jar包，Java调用Python新姿势！</a></p>
<p><a href="https://mp.weixin.qq.com/s/xp2S4_3UQTZ0TOIlVqM8uw">一个Java对象的回忆录：垃圾回收</a></p>
<p><a href="https://mp.weixin.qq.com/s/WkQ5mVZrF7V2GrU-rsPOdQ">内核地址空间大冒险3：权限管理</a></p>
<p><a href="https://mp.weixin.qq.com/s/lxpHhHVIh6DktoHzrRLaKA">谁动了你的HTTPS流量？</a></p>
<p><a href="https://mp.weixin.qq.com/s/7gM31s4-hTJTprJnxsHgEA">路由器里的广告秘密</a></p>
<p><a href="https://mp.weixin.qq.com/s/0b5e1_vwyvw8WOOHbVcQyQ">内核地址空间大冒险2：中断与异常</a></p>
<p><a href="https://mp.weixin.qq.com/s/JTr1-5nPtseAYXfvJdamVg">DDoS攻击：无限战争</a></p>
<p><a href="https://mp.weixin.qq.com/s/lerhjpAEdp4RiwsmetyqPg">一条SQL注入引出的惊天大案</a></p>
<p><a href="https://mp.weixin.qq.com/s/esc9gWg42vyPkT58HCKNgg">内核地址空间大冒险：系统调用</a></p>
<p><a href="https://mp.weixin.qq.com/s/suzicCzb2g5b8NN71S5Ngw">一个HTTP数据包的奇幻之旅</a></p>
<p><a href="https://mp.weixin.qq.com/s/_TOFIPGIeMHhVxIVToxmiQ">一个DNS数据包的惊险之旅</a></p>
<p><a href="https://mp.weixin.qq.com/s/-ggUa3aWkjjHjr9VwQL9TQ">我是一个流氓软件线程</a></p>
<h3 id="扫码关注，更多精彩"><center>扫码关注，更多精彩</center></h3>
<hr>
<p><img src="https://imgkr.cn-bj.ufileos.com/5de7751a-9e38-4718-994a-6136f7804ae5.png" alt=""></p>

</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-03-20 09:15</span>&nbsp;
<a href="https://www.cnblogs.com/xuanyuan/">轩辕之风</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12529598" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12529598);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 193695, cb_blogApp = 'xuanyuan', cb_blogUserGuid = '8508cac9-f21a-e411-8d02-90b11c0b17d6';
    var cb_entryId = 12529598, cb_entryCreatedDate = '2020-03-20 09:15', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 轩辕之风
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>