<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="中介者模式是一种常见的解耦思维的模式，本文对中介者模式进行了简单介绍，给出了中介者模式的意图，结构，以及意图发展演变，给出了中介者模式的Java代码示例，中介者模式又称为调停者模式，是迪米特法则的诠释" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>中介者模式 调停者 Mediator 行为型 设计模式（二十一） - noteless - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=BKtyzabbeYJEVOaELkxmRjHbp7LT-v37GzrU5S24bJk" />
    <link id="MainCss" rel="stylesheet" href="/skins/buildtowin/bundle-buildtowin.min.css?v=lp23bZd4RUCf9TGsihJRLSq5M_182P4N8YRMn1A2CWo" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/noteless/custom.css?v=fnk17ixpiOajP7an/OE6hUwN1aI=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/buildtowin/bundle-buildtowin-mobile.min.css?v=ADiCwO2hOTdd5yYidcx7eob7ix2VJI4o_TXjEycTHjs" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/noteless/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/noteless/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/noteless/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=wKnarAbt-YO5waLYR80IqCLKpzPpF-s-32JKmKCtJxg"></script>
    <script>
        var currentBlogId = 268100;
        var currentBlogApp = 'noteless';
        var cb_enable_mathjax = true;
        var isLogined = false;
        var skinName = 'BuildtoWin';
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <link rel="stylesheet" href="https://blog-static.cnblogs.com/files/noteless/cnblogs.css" type="text/css" />

<!--
<link rel="stylesheet" href="https://blog-static.cnblogs.com/files/noteless/monokai-sublime.css">
-->

<script src="https://blog-static.cnblogs.com/files/noteless/highlight.pack.js" defer></script>






<div class="main-top">

  <a class="avatar" href="https://www.cnblogs.com/noteless">
    <img src="//files.cnblogs.com/files/noteless/cnblogspic2.gif" alt="noteless 头像">
</a>
<div class="title">
    <a class="name" href="https://www.cnblogs.com/noteless/">noteless</a>
  </div>
<div class="info">

  </div>
</div>



<a href="#"><div id="toTop" style="zoom:0;display:none"></div></a>
    </div>
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/noteless/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/noteless/">noteless</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/noteless/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/noteless">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/noteless/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
212&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
89</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/noteless/p/10130616.html">中介者模式 调停者 Mediator 行为型 设计模式（二十一）</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
    <div id="cnblogs_post_description" style="display: none">
        中介者模式是一种常见的解耦思维的模式，本文对中介者模式进行了简单介绍，给出了中介者模式的意图，结构，以及意图发展演变，给出了中介者模式的Java代码示例，中介者模式又称为调停者模式，是迪米特法则的诠释。
    </div>
<div id="cnblogs_post_body" class="blogpost-body ">
    <div>&nbsp;</div>
<div>中介者模式（Mediator）</div>
<div>&nbsp;</div>
<div><span style="color: #ff0000; font-size: large; font-weight: bold;">调度、调停</span></div>
<div>&nbsp;</div>
<div><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114520481-226720076.png"><img style="display: inline; background-image: none;" title="image_5c171b2a_4f0c" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114521317-1400358813.png" alt="image_5c171b2a_4f0c" width="629" height="405" border="0" /></a></div>
<h3><span style="font-size: 18px;">意图 </span></h3>
<div><span style="color: #ff0000; font-size: large; font-weight: bold;">用一个中介对象（中介者）来封装一系列的对象交互，中<span style="line-height: 32px;">介者使各对象不需要显式地相互引用，从而使其耦合松散</span></span></div>
<div><span style="color: #ff0000; font-size: large; font-weight: bold;"><span style="line-height: 32px;">而且可以独立地改变它们之</span><span style="line-height: 32px;">间的交互。</span></span></div>
<div><span style="color: #000000; line-height: 32px; font-size: large; font-weight: bold;">中介者模式又称为调停者模式。</span></div>
<div style="line-height: 200%;">
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">面向对象的程序设计中，我们通常将功能进行分解，按照职责以类为维度进行划分，也就是使用时功能最终将分布在多个对象中</div>
<div style="line-height: 200%;">并且我们会尽可能的保持对象功能的单一（单一职责原则）</div>
<div style="line-height: 200%;">相对于对象的单一职责来说，任何的系统或者模块的功能却并不会单一，往往都是有多个对象交互协作来实现所有的功能</div>
<div style="line-height: 200%;">对象之间不可避免的需要建立连接</div>
<div style="line-height: 200%;">
<div style="line-height: 32px;">换句话说</div>
<div style="line-height: 32px;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>系统（或者某模块）必然是复杂的</strong></span>（没有什么系统可以几个对象就轻松搞定，那样或许也不能称之为系统了吧）</div>
<div style="line-height: 32px;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>功能必然会分布在多个对象中</strong></span></div>
<div style="line-height: 32px;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>多个对象协作必然需要联系</strong></span>，<span style="color: #0000ff; font-size: 13.5pt;"><strong>这</strong></span><span style="color: #0000ff; font-size: 13.5pt;"><strong>必然导致耦合的产生</strong></span></div>
</div>
<div style="line-height: 200%;"><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114521570-913749676.png"><img style="display: inline; background-image: none;" title="image_5c171b2a_724a" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114522145-1843703505.png" alt="image_5c171b2a_724a" width="418" height="310" border="0" /></a></div>
<div style="line-height: 200%;">如上图所示，虽然系统对外呈现是一个统一的整体，但是，内部各个模块之间很可能是紧密的耦合&nbsp;</div>
<div style="line-height: 200%;">各个<span style="color: #ff0000; font-size: 13.5pt;"><strong>模块相互联系，可能互相持有引用，会出现网状结构，完全不符合迪米特法则</strong></span>。</div>
<div style="line-height: 200%;">如果<span style="color: #ff0000; font-size: 13.5pt;"><strong>对系统进行改动，将会变得困难</strong></span>。</div>
<div style="line-height: 200%;"><hr style="height: 0px;" noshade="noshade" />
<div style="line-height: 24px;">我们以装修为例</div>
<div style="line-height: 24px;">一般装修公司都会给每一个项目配备一个项目经理（这个项目也就是你家这个单子了，项目经理就是包工头）</div>
<div style="line-height: 24px;">装修的一般阶段分为：前期设计&rarr;拆改&rarr;水电&rarr;瓦工&rarr;木工&rarr;油漆&rarr;安装&rarr;保洁&rarr;软装</div>
<div style="line-height: 24px;">&nbsp;</div>
<div style="line-height: 24px;">项目经理手上经常同时有几个工地在同步进行，只要错的开就好了</div>
<div style="line-height: 24px;">因为每个阶段都是有先后顺序的，你不可能先木工，然后再去拆改；</div>
<div style="line-height: 24px;">因为每个阶段也都需要一定时间，也意味着这一拨人不可能同时在你家工作</div>
<div style="line-height: 24px;">&nbsp;</div>
<div style="line-height: 24px;">开工后项目经理会进行工作安排</div>
<div style="line-height: 24px;">水电工结束了A之后，项目经理会安排他到B，然后安排瓦工到A，然后........</div>
<div style="line-height: 24px;">所有的顺序都是由项目经理负责调度，水电工可以完全不认识瓦工，他们也完全不需要进行联系</div>
<div style="line-height: 24px;">有事儿找项目经理</div>
<div style="line-height: 24px;">&nbsp;</div>
<div style="line-height: 24px;">如果没有项目经理，会是什么场景？</div>
<div style="line-height: 24px;">那就是人人都是项目经理，人人都需要管自己，还需要管别人</div>
<div style="line-height: 24px;">也就是每个人安排分配自己的时间与任务</div>
<div style="line-height: 24px;">水电工结束后需要联系瓦工进场，如果瓦工发现有遗留问题，需要联系水电工进行沟通</div>
<div style="line-height: 24px;">木工需要联系瓦工确认进展情况，油漆工又需要确认木工状况...</div>
<div style="line-height: 24px;">你会发现他们必须要经常保持联系，以获得进展情况，进而安排自己的工作</div>
<div style="line-height: 24px;">&nbsp;</div>
<div style="line-height: 24px;">一个包工队尚且如此，如果是一个大的装修公司，怎么办？</div>
<div style="line-height: 24px;">而且装修而言，阶段之间还会有顺序，油漆工用不到联系水电工</div>
<div style="line-height: 24px;">但是在系统中，对象岂会仅仅与一个对象联系？</div>
<div style="line-height: 24px;">那岂不是更复杂、乱套？</div>
<hr style="height: 0px;" noshade="noshade" /></div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">
<div style="line-height: 32px;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>中介者模式就是为了解决系统内部的调度问题，降低系统内部各模块之间的耦合度。</strong></span></div>
<div><span style="color: #000000; font-size: 13.5pt;"><strong>装修公司的项目经理、小组组长、班长，团队leader等其实这都是中介者模式的体现。</strong></span></div>
<div>&nbsp;</div>
</div>
<div style="line-height: 200%;">有很多书中以&ldquo;房屋中介&rdquo;作为中介者模式的一种场景</div>
<div style="line-height: 200%;">个人认为对于某一个房东或者租客而言，&ldquo;房屋中介&rdquo;的含义是为你服务的中介人员，此时的含义更接近代理模式</div>
<div style="line-height: 200%;">而从广义上看，有很多租客、买家，也存在很多房东，&ldquo;房屋中介&rdquo;将他们联系在一起，此时的&ldquo;房租中介&rdquo;应该是中介公司，这时才更符合中介者模式的含义</div>
<div style="line-height: 200%;"><span style="color: #000000; font-size: 13.5pt;"><strong>中介者模式的重点在于&ldquo;调度、协调&rdquo;，含义更接近&ldquo;指挥中心&rdquo;</strong></span>，<span style="color: #0000ff; font-size: 13.5pt;"><strong>被指挥的是该系统内部的成员</strong></span></div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">
<div><span style="color: #0000ff; font-size: 13.5pt;"><strong>如果在一个系统中对象之间存在多对多的相互关系</strong></span></div>
<div><span style="color: #0000ff; font-size: 13.5pt;"><strong>我们可以将对象之间的一些交互行为从<span style="line-height: 32px;">各个对象中分离出来，并集中封装在一个中介者对象中，并由该中介者进行统一协调</span></strong></span></div>
<div><span style="line-height: 32px;"><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114522366-149015208.png"><img style="display: inline; background-image: none;" title="image_5c171b2a_66af" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114522738-826098378.png" alt="image_5c171b2a_66af" width="376" height="287" border="0" /></a></span></div>
<div><span style="line-height: 32px;">如上图所示，</span><span style="line-height: 32px;">对象之间<span style="color: #ff0000; font-size: 13.5pt;"><strong>多对多</strong></span>的复杂关系就<span style="color: #ff0000; font-size: 13.5pt;"><strong>转化为</strong></span>相对简单的<span style="color: #ff0000; font-size: 13.5pt;"><strong>一对多关系</strong></span></span></div>
<div style="line-height: 200%;">简化了对象之间的复杂交互</div>
<div style="line-height: 200%;">显然，中介者模式是<span style="color: #000000; font-size: 13.5pt;"><strong>迪米特法则</strong></span>（不要和陌生人说话）的典型。&nbsp;&nbsp;</div>
<div style="line-height: 200%;">
<h3><span style="font-size: 18px;">结构</span>&nbsp;&nbsp;</h3>
</div>
</div>
<div style="line-height: 200%;"><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114522938-1003889382.png"><img style="display: inline; background-image: none;" title="image_5c171b2a_260e" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114523192-296305867.png" alt="image_5c171b2a_260e" width="624" height="258" border="0" /></a></div>
<div style="line-height: 200%;">
<div><span style="color: #0000ff; font-size: 13.5pt;"><strong>同事角色Colleague</strong></span></div>
<div style="line-height: 200%;">系统中所有组成部件的抽象角色</div>
</div>
<div style="line-height: 200%;">
<div style="line-height: 200%;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>具体的同事角色ConcreteColleague</strong></span></div>
<div style="line-height: 200%;">系统的每一个具体的组成部分，就像公司的每个同事</div>
<div style="line-height: 200%;">提供自身职责功能的方法接口，供中介者调用</div>
<div style="line-height: 200%;">定义中介者到同事对象的接口，也就是提供接口给中介者调用</div>
<div style="line-height: 200%;">中介者（项目经理）根据你的技能分配任务，也就是调用你的方法</div>
<div style="line-height: 200%;">
<div style="line-height: 200%;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>中介者角色Mediator</strong></span></div>
<div style="line-height: 200%;">定义了同事Colleague对象到中介者的接口，也就是所有同事通信的接口（同事间的通信借助于中介者提供的这个方法）</div>
<div style="line-height: 200%;">也就是提供一个方法给同事们调用，用来请求其他同事协助协助，这个方法是中介者提供的</div>
<div style="line-height: 200%;">这个方法典型的示例就是事件处理方法</div>
</div>
<div style="line-height: 200%;">
<div style="line-height: 200%;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>具体的中介者ConcreteMediator</strong></span></div>
<div style="line-height: 200%;">具体的中介者，实现Mediator定义的接口，协调各同事进行协作</div>
</div>
&nbsp;&nbsp;</div>
<div style="line-height: 200%;">所有的成员之间，可以相互协调工作，但是却又不直接相互管理</div>
<div style="line-height: 200%;">这些对象都与项目经理&ldquo;中介者&rdquo;进行紧密联系</div>
<div style="line-height: 200%;">由项目经理进行工作协调，每个组成部分就如同我们项目组中的一个成员，也就是同事一样，这也是上文中Colleague 角色的由来</div>
<div style="line-height: 200%;"><span style="color: #000000; font-size: 13.5pt;"><strong>如何相互协调工作但是却又不直接相互管理</strong></span>？比如</div>
<div style="line-height: 200%;">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> A{
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> f(){
</span><span style="color: #008000;">//</span><span style="color: #008000;">do sth</span><span style="color: #000000;">
B b </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
b.g();
}</span></pre>
</div>
</div>
<div style="line-height: 200%;">上面伪代码中</div>
<div style="line-height: 200%;">类A有一个方法f ，做了一些事情之后，创建了一个B的对象b，然后调用b的方法g，做了一些处理</div>
<div style="line-height: 200%;">这就是A与B的协作，A也同时具有管理B的职责</div>
<div style="line-height: 200%;">如果转换为下面的形式，就是中介者模式</div>
<div style="line-height: 200%;">A和B的协作不在具有对象管理关系，而是项目经理Mediator统一进行管理&nbsp;</div>
<div style="line-height: 200%;">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Mediator{
A a </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> A();
B b </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> B();
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> cooperation(){
a.f();
b.g();
}
}</span></pre>
</div>
</div>
<h3><span style="font-size: 18px;">代码示例</span></h3>
<div style="line-height: 200%;">使用《设计模式 可复用面向对象软件的基础》中的例子为原型</div>
<div style="line-height: 200%;">
<div><span style="color: #000000; font-size: 13.5pt;"><strong>考虑一个图形用户界面中对话框的实现。</strong></span></div>
<div style="line-height: 200%;"><span style="color: #000000; font-size: 13.5pt;"><strong>对话框使用一个窗口来展现一系列的窗口组件，比如按钮菜单输入域等</strong></span></div>
</div>
<div style="line-height: 200%;">
<div>比如下图，IDEA的字体设置窗口，当进行Font字体设置时</div>
<div>
<ul>
<li>预览区域内的字体将会发生变化</li>
<li>右下角的Apply 应用按钮将成为可点击状态</li>
</ul>
</div>
</div>
<div style="line-height: 200%;"><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114523398-553616787.png"><img style="display: inline; background-image: none;" title="image_5c171b2b_350a" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114523686-1975121987.png" alt="image_5c171b2b_350a" width="909" height="550" border="0" /></a></div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">一种可能的解决方法</div>
<div style="line-height: 200%;">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator.simple;
 
</span><span style="color: #008000;">/**</span><span style="color: #008000;">
* 设置字体类,提供字体设置方法.
* 并且创建展示Display对象,调用reDisplay方法重新展示
* 并且创建按钮Button对象,调用applyButton方法使能应用按钮
</span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Font {
 
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setFont() {
    System.out.println(</span>"设置字体..."<span style="color: #000000;">);
    Display display </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Display();
    display.reDisplay();
    Button button </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Button();
    button.applyButton();
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator.simple;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Display {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> reDisplay() {
        System.out.println(</span>"字体重新展示..."<span style="color: #000000;">);
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator.simple;
 
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Button {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> applyButton() {
        System.out.println(</span>"应用按钮可用..."<span style="color: #000000;">);
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator.simple;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Font font </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Font();
    font.setFont();
    }
}</span>&nbsp;</pre>
</div>
</div>
<div style="line-height: 200%;">
<div><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114523917-1950024943.png"><img style="display: inline; background-image: none;" title="image_5c171b2b_398c" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114524091-1461914172.png" alt="image_5c171b2b_398c" width="512" height="122" border="0" /></a></div>
</div>
<div style="line-height: 200%;">上面的示例很简单</div>
<div style="line-height: 200%;">为了实现&ldquo;点击设置字体，选择字体后预览框字体的改变以及使能应用按钮的功能&rdquo;</div>
<div style="line-height: 200%;">也就是<span style="color: #000000; font-size: 13.5pt;"><strong>联动</strong></span>的功能</div>
<div style="line-height: 200%;">设置字体后，分别创建展示和按钮对象，调用对象的方法</div>
<div style="line-height: 200%;">很显然，<span style="color: #000000; font-size: 13.5pt;"><strong>字体不仅操心自己的事情，还管理着展示Display和按钮Button</strong></span></div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">而且，如果直接点击取消会发生什么？一切将会还原,又伴随着一系列的调用</div>
<div style="line-height: 200%;">难道仍旧需要：&ldquo;不仅操心自己的事情，还要负责管理别人么&rdquo;？</div>
<div style="line-height: 200%;">就像没有项目经理的包工队一样了，既操心自己又要管理别人</div>
<div style="line-height: 200%;">成了我们上面所说的网状结构，内部各个同事之间的耦合度极高</div>
<h4><span style="font-size: 16px;">重构中介者模式 </span></h4>
<div style="line-height: 200%;">
<div>重构的业务逻辑:</div>
<div style="line-height: 200%;">
<ul>
<li>通过引入mediator中介者，作为同事之间协作的中间人，提供operation（）方法，用于同事间请求协助、事件处理</li>
<li>每个同事类都知道这个中介，所以在抽象角色Colleague中设置了Mediator属性，构造方法注入，并且提供notifyEvent方法，封装了mediator的operation（）方法</li>
<li>当具体的同事ConcreteColleague，执行操作后，需要其他同事协作时，直接调用notifyEvent（）方法</li>
<li>每个具体的同事提供自身的职责接口</li>
</ul>
</div>
<div>简单地说就是，提供中介者&ldquo;项目经理&rdquo;mediator，提供事件处理方法</div>
<div>所有的同事都只知道&ldquo;项目经理&rdquo;，如果有事需要其他同事办，就叫&ldquo;项目经理&rdquo;。</div>
<div>&nbsp;</div>
<div>&nbsp;</div>
</div>
<div style="line-height: 200%;">Mediator抽象中介者角色定义了operation方法</div>
<div style="line-height: 200%;">各个Colleague对象通过此方法进行通信，接受参数类型为Colleague的对象&nbsp;</div>
<div style="line-height: 200%;">
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Mediator {
</span><span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> operation(Colleague event);
}</span></pre>
</div>
</div>
<div>Colleague抽象同事角色拥有Mediator，通过构造方法注入</div>
<div>提供了notifyEvent方法，调用中介者的operation方法，并且将自身作为参数</div>
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Colleague {
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Mediator mediator;
    Colleague(Mediator mediator) {
        </span><span style="color: #0000ff;">this</span>.mediator =<span style="color: #000000;"> mediator;
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> notifyEvent() {
        mediator.operation(</span><span style="color: #0000ff;">this</span><span style="color: #000000;">);
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Button <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Colleague {
    Button(Mediator mediator){
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(mediator);
    }
     
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> applyButton() {
        System.out.println(</span>"应用按钮可用..."<span style="color: #000000;">);
    }
}</span></pre>
</div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator;
 
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Display <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Colleague {
    Display(Mediator mediator) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(mediator);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> reDisplay() {
        System.out.println(</span>"字体重新展示..."<span style="color: #000000;">);
    }
}</span></pre>
</div>
</div>
</div>
<div style="line-height: 200%;">
<p style="margin: 0px;">&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator;
 
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> Font <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Colleague {
</span><span style="color: #0000ff;">private</span><span style="color: #000000;"> String fontName;
 
    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String getFontName() {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> fontName;
    }
     
    Font(Mediator mediator) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(mediator);
    }
     
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> changeFont() {
        System.out.println(</span>"设置字体......"<span style="color: #000000;">);
        fontName </span>= "微软雅黑"<span style="color: #000000;">;
        notifyEvent();
    }
}</span></pre>
</div>
</div>
<div style="line-height: 200%;">ConcreteMediator实现了Mediator定义的接口</div>
<div style="line-height: 200%;">并且内部维护三个对象</div>
<div style="line-height: 200%;">如果事件类型是Font，那么调用设置字体的事件</div>
<div style="line-height: 200%;">
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator;
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> ConcreteMediator <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Mediator {
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Button button;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Display display;
    </span><span style="color: #0000ff;">private</span><span style="color: #000000;"> Font font;
     
    ConcreteMediator() {
        button </span>= <span style="color: #0000ff;">new</span> Button(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        display </span>= <span style="color: #0000ff;">new</span> Display(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
        font </span>= <span style="color: #0000ff;">new</span> Font(<span style="color: #0000ff;">this</span><span style="color: #000000;">);
    }
     
    @Override
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> operation(Colleague event) {
        </span><span style="color: #0000ff;">if</span> (event <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Font) {
        setFontEvent(event);
    }
    }
     
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> setFontEvent(Colleague event) {
        System.out.println(((Font) event).getFontName());
        button.applyButton();
        display.reDisplay();
    }
}</span></pre>
</div>
</div>
<div style="line-height: 200%;">测试代码</div>
<div style="line-height: 200%;">
<div>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">package</span><span style="color: #000000;"> mediator;
 
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args){
        Mediator mediator </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> ConcreteMediator();
        Font font </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Font(mediator);
        font.changeFont();
    }
}</span></pre>
</div>
<p>&nbsp;</p>
</div>
<div><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114524330-2055656166.png"><img style="display: inline; background-image: none;" title="image_5c171b2b_3c66" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114524518-1616234599.png" alt="image_5c171b2b_3c66" width="527" height="150" border="0" /></a></div>
</div>
<div style="line-height: 200%;">上面的示例中，以设置字体为例，当字体变化时，请求&ldquo;项目经理&rdquo;安排其他同事协助</div>
<div style="line-height: 200%;">&ldquo;项目经理&rdquo;operation(Colleague event)&nbsp; 发现是设置字体的事件后，调用对应的事件处理方法，也就是寻找其他同事进行协助</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">
<div style="line-height: 32px;">中介者模式将每个场景中对象之间的协作进行封装&nbsp;&nbsp;</div>
<h4><span style="font-size: 16px;">小结 </span></h4>
<div style="line-height: 32px;">
<div style="line-height: 32px;">当你需要其他同事协助时，肯定不需要项目经理每次都创建具体的同事对象</div>
<div style="line-height: 32px;">上面的示例中，在ConcreteMediator的构造方法中创建的各个具体同事的实例(可以理解为项目经理手下有你和你的一帮同事)</div>
<div style="line-height: 32px;">你还<span style="color: #ff0000; font-size: 13.5pt;"><strong>可以提取出来工厂类用于管理同事类和中介者类</strong></span></div>
<div style="line-height: 32px;">比如通过一个工厂对象管理各个同事实例（如果可以还可以将各个同事都设置为单例 ）</div>
<div style="line-height: 32px;">并且中介者类作为这个工厂对象的内部类</div>
<div style="line-height: 32px;">&nbsp;</div>
<div style="line-height: 32px;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>同事对象的传递可以达到信息的获取与回调</strong></span></div>
<div style="line-height: 32px;">通过给Font加了一个fontName属性，通过打印信息可以看得出来</div>
<div style="line-height: 32px;">通过将当时发生事件的对象传递了过来，可以获得事件的更多信息，可以根据信息进一步的进行操作</div>
<div style="line-height: 32px;">比如，此处的设置了字体，设置了什么字体？这一进一步的信息就通过参数携带进来</div>
<div style="line-height: 32px;">而且，这种方式还可以通知到Font本身</div>
<div style="line-height: 32px;">也就是可以在setFontEvent(Colleague event) 事件处理中，调用Font的方法进行结果返回，有回调的韵味</div>
<div style="line-height: 32px;">&nbsp;</div>
<div style="line-height: 32px;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>良好的扩展性</strong></span></div>
<div style="line-height: 32px;">如果需要增加一个新的事件处理过程，比如点击取消按钮，还原字体设置，还原预览按钮</div>
<div style="line-height: 32px;">只需要在Button新增加一个职责（方法），然后在ConcreteMediator中新增加一种类型的事件处理程序即可</div>
<div style="line-height: 32px;">&nbsp;</div>
<div style="line-height: 32px;">上面的示例中仅仅定义了几个简单的方法，实践中每个具体同事角色自然不会仅仅只有几个方法</div>
<div style="line-height: 32px;">不管有多少方法，都可以通过中介者将他们的协作逻辑进行封装</div>
<div style="line-height: 32px;">通过具体的中介者ConcreteMediator的处理方法进行安排</div>
<div style="line-height: 32px;">中介者模式可以很好地应用于事件通知的处理</div>
</div>
</div>
<h4><span style="font-size: 16px;">中介者模式时序图 </span></h4>
<div style="line-height: 200%;"><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114524956-543378059.png"><img style="display: inline; background-image: none;" title="image_5c171b2b_1ce5" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114525182-1197250303.png" alt="image_5c171b2b_1ce5" width="894" height="389" border="0" /></a></div>
<div style="line-height: 200%;">当某一个同事对象产生事件后，如果需要其他同事进行协助，他将调用中介者的方法</div>
<div style="line-height: 200%;">中介者接到消息后，调用其他同事的方法（安排其他同时干活），然后最终还可以将消息进行返回</div>
<h3><span style="font-size: 18px;">与门面模式对比 </span></h3>
<div style="line-height: 200%;"><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114525379-1559457159.png"><img style="display: inline; background-image: none;" title="image_5c171b2b_31b0" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114525819-1756510185.png" alt="image_5c171b2b_31b0" width="938" height="569" border="0" /></a></div>
<div style="line-height: 200%;"><span style="font-size: 13.5pt;"><strong><span style="color: #000000;">门面模式和中介者模式</span><span style="color: #ff0000;">都是通过中间类降低系统的耦合度</span></strong></span></div>
<div style="line-height: 200%;">
<div style="line-height: 200%;">但是门面模式是为了子系统提供一个简单一致的接口，客户端透过门面类向子系统发送消息，可以认为消息的发送是单方向的</div>
<div style="line-height: 200%;">客户端---&gt;门面---&gt;子系统方法，子系统提供功能给客户端</div>
<div style="line-height: 200%;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>门面是在外部客户端和内部子系统之间</strong></span></div>
</div>
<div style="line-height: 200%;">
<div style="line-height: 200%;">中介者模式中，则是主要复杂系统内部多个对象之间的相互协作</div>
<div style="line-height: 200%;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>中介者是各个内部对象同事之间</strong></span>&nbsp;&nbsp;</div>
</div>
<h3><span style="font-size: 18px;">扩展 </span></h3>
<div style="line-height: 200%;">任何模式都不是一成不变的，模式结构图只是一种相对比较合适准确的方案</div>
<div style="line-height: 200%;">但是涉及到具体的业务中，一切都是可变的</div>
<div style="line-height: 200%;">中介者模式也有多种灵活性</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>如果只有一个中介者对象，显然抽象Mediator角色是可以隐藏的</strong></span></div>
<div style="line-height: 200%;">那么ConcreteMediator就兼顾了这个角色，提供通信接口给同事角色</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">中介者模式的本质含义是负责协调系统内部的多个交互的对象，将同事进行解耦</div>
<div style="line-height: 200%;">也就是说<span style="color: #ff0000; font-size: 13.5pt;"><strong>实现共同的接口并不是必须的</strong></span></div>
<div style="line-height: 200%;">而实际上，一个系统中协作的多个对象，很可能是不同的类型，如果去掉了抽象角色Colleague</div>
<div style="line-height: 200%;">那么就可以将任意的有关联的对象组织在一起，通过中介者协同工作</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">而且，也并不意味着一定要中介者持有同事角色，如果合适，直接创建中介者也并非不可以</div>
<div style="line-height: 200%;">虽然上面提到你可以使用另外的工厂管理，那也只是一种常用用法而已。</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">只需要记住中介者的本质在于&ldquo;<span style="color: #ff0000; font-size: 13.5pt;"><strong>行为与协作的分离，中介者封装了对象间的协作</strong></span>&rdquo;</div>
<h3><span style="font-size: 18px;">总结 </span></h3>
<div style="line-height: 200%;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>中介者模式将对象的行为和协作进行分离，使对象更加专注于对象的行为，也就是自身的功能</strong></span></div>
<div style="line-height: 200%;"><span style="color: #ff0000; font-size: 13.5pt;"><strong>将协作分离出来封装到中介者内部</strong></span></div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">迪米特法则，不要和陌生人讲话，只与你的朋友通信，<span style="color: #ff0000; font-size: 13.5pt;"><strong>中介者模式是迪米特法则的典型应用</strong></span></div>
<div style="line-height: 200%;">通过引入中介者对象，在同事之间的请求调用中，增加了&ldquo;项目经理&rdquo;，如果有事搞不定，需要协助，那么就找他&nbsp;</div>
<div style="line-height: 200%;">每个人只和项目经理对话，也就是仅仅和项目经理这个朋友聊天,其他的同事都不理了&nbsp;&nbsp; ￣□￣｜｜</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>中介者将网状结构，转换为了星型结构</strong></span></div>
<div style="line-height: 200%;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>将多对多的关系，转换为了一对多的关系</strong></span></div>
<div style="line-height: 200%;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>所以中介者模式将系统中对象对其他对象的引用数目降到最低，简化了对象之间的交互</strong></span>。</div>
<div style="line-height: 200%;"><a href="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114526104-760698474.png"><img style="display: inline; background-image: none;" title="image_5c171b2b_3f1e" src="https://img2018.cnblogs.com/blog/897393/201812/897393-20181217114526318-886625351.png" alt="image_5c171b2b_3f1e" width="889" height="332" border="0" /></a></div>
<div style="line-height: 200%;"><span style="color: #0000ff; font-size: 13.5pt;"><strong>中介者模式将各个同事对象之间进行解耦，增加新的中介者或者同事都比较方便，符合开闭原则</strong></span></div>
<div style="line-height: 200%;">MVC模式，也是一种典型的中介者模式，控制器负责视图层和模型层的调度处理，是一个明显的中介者。</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">中介者模式将同事进行解耦，但是各个Colleague类必须同中介者进行交互</div>
<div style="line-height: 200%;">更准确的说，解耦后的关系植入到了中介者自身，如果原来的同事对象间的相互调用非常复杂</div>
<div style="line-height: 200%;">那么，这个中介者也很可能非常的复杂难以维护</div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">换言之，<span style="color: #ff0000; font-size: 13.5pt;"><strong>同事间的复杂性与耦合性转移到了中介者内部</strong></span></div>
<div style="line-height: 200%;">中介者内部对于各个同事之间的协调代码不太可能复用，所以<span style="color: #ff0000; font-size: 13.5pt;"><strong>具体同事类的复用性也是以中介者的不可复用为代价的</strong></span></div>
<div style="line-height: 200%;">&nbsp;</div>
<div style="line-height: 200%;">如果系统中的各个对象之间存在复杂的引用关系，希望能够通过中间类将他们进行解耦</div>
<div style="line-height: 200%;">或者系统中对象间的引用混乱，交互太多，导致难以进行类的复用</div>
<div style="line-height: 200%;">你就可以考虑中介者模式</div>
<div style="line-height: 200%;">但是并不意味着任何涉及到多个类交互的地方都用中介者模式，如果原本并不复杂，使用中介者将会增加复杂度</div>
<div style="line-height: 200%;">基本前提就是紧密耦合，比如出现了网状结构</div>
<div style="line-height: 200%;">原文地址:<a href="https://www.cnblogs.com/noteless/p/10130616.html" target="_blank">中介者模式 调停者 Mediator 行为型 设计模式（二十一）</a></div>
</div>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2018-12-17 12:38</span>&nbsp;
<a href="https://www.cnblogs.com/noteless/">noteless</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=10130616" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(10130616);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 268100, cb_blogApp = 'noteless', cb_blogUserGuid = '2f3ff2be-bdda-e511-9fc1-ac853d9f53cc';
    var cb_entryId = 10130616, cb_entryCreatedDate = '2018-12-17 12:38', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 noteless
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <script>
/*
$(document).ready(function() {
  $('pre').each(function(i, e) {hljs.highlightBlock(e)});
});
*/
</script>





<script>




//初始化加载函数
$(function(){
    // hideIndexArticle();
    appendNavigator();

    addOriginURL();

addSupport();
hideToTop();


})


//隐藏首页除置顶外的其他所有文章列表
function hideIndexArticle(){
    var windowURL = window.location.href;
    console.log(windowURL )
    if(windowURL && windowURL.indexOf('www.cnblogs.com/noteless')>0 && windowURL.indexOf('html')<0){
        //$('#mainContent .day:not(:first)').css('display','none');
    }
}

//增导航条上增加 目录索引按钮
function appendNavigator(){
    var _html='<li>'
        +'<a id="blog_nav_admin" class="menu" rel="nofollow" href="https://www.cnblogs.com/noteless/p/9400742.html">'
        +'目录索引'
        +'</a>'
        +'</li>';

    $('#navList').append(_html);
}

function appendMenuItem(tagName,id,content){
    console.log(tagName+" "+tagName.substring(1));
    var paddingLeft = tagName.substring(1) * 30; //添加标题缩进
    $('#menu_nav_ol').append('<li class="' + id +'" style="padding-left: '+ paddingLeft +'px;"><b>' + content + '</b></li>');
}


//添加支持一下，请求关注
function addSupport(){

var zhichiHml = '<p>'
+'<span>'
+'<img src="https://files-cdn.cnblogs.com/files/noteless/zhichiyixaa.bmp" alt="">'
+'</span>'
+'</p>';
$('#cnblogs_post_body').append(zhichiHml );

}

//每篇文章增加原文地址
function addOriginURL(){

    //文章增加原文地址
    var originURL='<div>'
        +'原文地址:'
        +'<a href="'
        +window.location.href
        +'" target="_blank">'
        +$('.postTitle a').html()
        +'</a>'
        +'</div>';
		
	originURL+='<img src="https://blog-static.cnblogs.com/files/noteless/%E4%BA%8C%E7%BB%B4%E7%A0%812.gif"></img>';
		
		
    if($("#cnblogs_post_body h3:first").length>0){
        $("#cnblogs_post_body h3:first").before(originURL);
    }else{
        $('#cnblogs_post_body').prepend(originURL);
    }


}

//如果是pc展示返回顶部
function hideToTop(){

	if(isPC()){
		$('#toTop').show();
	}
}


//判断手机还是pc
function isPC() {
   var userAgentInfo = navigator.userAgent;
   var Agents = ["Android", "iPhone",
      "SymbianOS", "Windows Phone",
      "iPad", "iPod"];
   var flag = true;
   for (var v = 0; v < Agents.length; v++) {
      if (userAgentInfo.indexOf(Agents[v]) > 0) {
         flag = false;
         break;
      }
   }
   return flag;
}



//根据标题生成左侧边栏的目录树
// 生成目录开始

$(function () {

	//如果是手机隐藏目录
	if(isPC()){

		//内容拼接
		$('body').append(
			'<div id="article-outline">'
			+'<div style="height:15px;">'
			+'<button type="button" class="close" data-dismiss="modal" aria-hidden="true">'
			+'X'
			+'</button>'
			+'</div>'
			+'</div>'
			+'<style>'
			+'#article-outline{'
			+'display:none;'
			+'min-width:140p;'
			+'max-width: 230px;'
			//+'max-height: 350px;'
			+'position:absolute;'
			+'float: left;'
			+'top:150px;'
			+'left:-999px;'
			+'border:1px solid #ccc;'
			+'box-shadow:5px 5px 2px #ccc;'
			+'padding: 5px 10px;'
			+'background-color: #fff;'
			+'overflow-y: auto;'
			+'scroll-x: auto;'
			+'}'

			+'#article-outline ul{'
			+'margin:5px 0 5px 0;'
			+'padding-left:30px;'
			+'font-size:12px;'
			+'border-left:1px dotted #ccc;'
			+'}'

			+'#article-outline ul:first-child{'
			+'padding-left:15px;'
			+'border:none;'
			+'}'

			+'#article-outline li{'
			+'list-style-type:decimal;'
			+'margin:3px 0;'
			+'}'

			+'#article-outline a{'
			+'color:#00C1E4;'
			+'}'
			+'</style>'
		)
		
		

		
		
		//取得新添加的目录元素
		var jOutline = $('#article-outline');

		//获取文章内容
		//var jContent = $('article .content');
		var jContent = $('div#topics');

		//计算高度
		var jContentHeight = jContent.height();

		//关闭按钮
		jOutline.find('.close').on('click', function () {
			jOutline.hide();
		})

		updateOutline();

		var top = jOutline.offset().top;
		scrollOutline();
		$(window).on('scroll', scrollOutline);

		function scrollOutline() {
			var scrollTop = $(document).scrollTop();
			var maxTop = jContent.offset().top + jContent.height() - jOutline.height();
			//设置行内样式
			if (scrollTop >= top && scrollTop <= maxTop) {
				jOutline.css({'position': 'fixed', 'top': 0});
			}
			else if (scrollTop < top) {
				/*
							jOutline.css({'position': 'absolute','float':'left', 'top': '150px'});
				*/
				jOutline.css({'position': 'absolute', 'top': '200px'});
			}
			else {
				/*
							jOutline.css({'position': 'absolute','float':'left', 'top': maxTop + 'px'});
				*/
				jOutline.css({'position': 'absolute', 'top': maxTop + 'px'});
			}

		}

		function updateOutline() {
			//设置哪些级别的目录
			// var arrAllHeader = jContent.find("h1,h2,h3,h4,h5,h6");
			var arrAllHeader = jContent.find("h2,h3,h4,h5,h6");
			var arrOutline = ['<ul>'];
			var header, headerText;
			var id = 0;
			var level = 0,
				lastLevel = 1;
			var levelCount = 0;
			for (var i = 0, c = arrAllHeader.length; i < c; i++) {
				header = arrAllHeader[i];
				headerText = $(header).text();

				header.setAttribute('id', id);

				level = header.tagName.match(/^h(\d)$/i)[1];
				levelCount = level - lastLevel;

				if (levelCount > 0) {
					for (var j = 0; j < levelCount; j++) {
						arrOutline.push('<ul>');
					}
				} else if (levelCount < 0) {
					levelCount *= -1;
					for (var j = 0; j < levelCount; j++) {
						arrOutline.push('</ul>');
					}
				}
				;
				arrOutline.push('<li>');
				arrOutline.push('<a href="#' + id + '">' + headerText + '</a>');
				arrOutline.push('</li>');
				lastLevel = level;
				id++;
			}
			arrOutline.push('</ul>')
			if (arrOutline.length > 2) {
				jOutline.append(arrOutline.join(''));
				jOutline.find('ul').each(function (i, n) {
					var jThis = $(this);
					if (jThis.children('li').length === 0) {
						jThis.replaceWith(jThis.children());
					}
				});
				showOutline();
			}
			else {
				hideOutline();
			}
		}

		function showOutline() {
			var offset = jContent.offset();

			//目录左侧偏移量
			/*        jOutline.css({
						left: offset.left + jContent.width() + 10 + 'px',
					}).show();*/
			jOutline.css({
				left:8 + 'px',
			}).show();
		}

		function hideOutline() {
			jOutline.hide();
		}
	
	
	}




    
});

//生成目录结束




</script>
    </div>
</body>
</html>